/**

Generated by the following Solidity interface...
```solidity
interface AaveLooper {
    error AddressEmptyCode(address target);
    error AddressInsufficientBalance(address account);
    error FailedInnerCall();
    error SafeERC20FailedOperation(address token);

    constructor(address owner, address asset, address lendingPool, address incentives);

    function ASSET() external view returns (address);
    function INCENTIVES() external view returns (address);
    function LENDING_POOL() external view returns (address);
    function OWNER() external view returns (address);
    function SAFE_BUFFER() external view returns (uint256);
    function USE_VARIABLE_DEBT() external view returns (uint256);
    function _borrow(uint256 amount) external;
    function _redeemSupply(uint256 amount) external;
    function _repayBorrow(uint256 amount) external;
    function _supply(uint256 amount) external;
    function _withdrawToOwner(address asset) external returns (uint256);
    function claimRewardsToOwner() external;
    function emergencyFunctionCall(address target, bytes memory data) external;
    function emergencyFunctionDelegateCall(address target, bytes memory data) external;
    function enterPosition(uint256 principal, uint256 iterations) external returns (uint256);
    function enterPositionFully(uint256 iterations) external returns (uint256);
    function exitPosition(uint256 iterations) external returns (uint256);
    function getAssetBalance() external view returns (uint256);
    function getAssetPrice() external view returns (uint256);
    function getBorrowBalance() external view returns (uint256);
    function getLTV() external view returns (uint256);
    function getLiquidity() external view returns (uint256);
    function getPendingRewards() external view returns (uint256);
    function getPositionData() external view returns (uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor);
    function getSupplyAndBorrowAssets() external view returns (address[] memory assets);
    function getSupplyBalance() external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "lendingPool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "incentives",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "ASSET",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ERC20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INCENTIVES",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IAaveIncentivesController"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LENDING_POOL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ILendingPool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OWNER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SAFE_BUFFER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "USE_VARIABLE_DEBT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "_borrow",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_redeemSupply",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_repayBorrow",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_supply",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_withdrawToOwner",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimRewardsToOwner",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "emergencyFunctionCall",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "emergencyFunctionDelegateCall",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enterPosition",
    "inputs": [
      {
        "name": "principal",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "iterations",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enterPositionFully",
    "inputs": [
      {
        "name": "iterations",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "exitPosition",
    "inputs": [
      {
        "name": "iterations",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getAssetBalance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAssetPrice",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBorrowBalance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLTV",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLiquidity",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPendingRewards",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPositionData",
    "inputs": [],
    "outputs": [
      {
        "name": "totalCollateralETH",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "totalDebtETH",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "availableBorrowsETH",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "currentLiquidationThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "ltv",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "healthFactor",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSupplyAndBorrowAssets",
    "inputs": [],
    "outputs": [
      {
        "name": "assets",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSupplyBalance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressInsufficientBalance",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "FailedInnerCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod AaveLooper {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x61010060405234801561001157600080fd5b506040516120cd3803806120cd83398101604081905261003091610122565b836001600160a01b0381166100765760405162461bcd60e51b815260206004820152600760248201526606f776e657220360cc1b60448201526064015b60405180910390fd5b6001600160a01b0390811660805283161580159061009c57506001600160a01b03821615155b80156100b057506001600160a01b03811615155b6100e85760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b604482015260640161006d565b6001600160a01b0392831660a05290821660c0521660e05250610176565b80516001600160a01b038116811461011d57600080fd5b919050565b6000806000806080858703121561013857600080fd5b61014185610106565b935061014f60208601610106565b925061015d60408601610106565b915061016b60608601610106565b905092959194509250565b60805160a05160c05160e051611e146102b96000396000818161023301528181610e910152610f6c015260008181610313015281816103fd015281816107260152818161079e015281816109060152818161097e01528181610a8b01528181610c8e01528181610d5101528181610fc3015261118a015260008181610288015281816103cf0152818161056d0152818161060a015281816107040152818161076201528181610816015281816108e40152818161094201528181610a5e01528181610c4b01528181610d1c01528181610e64015281816110bb01526112650152600081816101f40152818161050e015281816106ba0152818161089a015281816109fb01528181610b0e01528181610bc701528181610bf701528181610cc801528181610d8d01528181610ecb015281816110ff01526112150152611e146000f3fe608060405234801561001057600080fd5b506004361061018e5760003560e01c806363e54bb1116100de578063ca20659111610097578063e78d73ad11610071578063e78d73ad14610355578063e8c944e614610368578063e8f3796314610370578063fbdf7b45146103a557600080fd5b8063ca2065911461033d578063d9621f9e14610345578063e54f08801461034d57600080fd5b806363e54bb1146102cd57806376307313146102e057806378dc9059146102f35780638a0ccf6c14610306578063b4dcfc771461030e578063bd345f141461033557600080fd5b8063183b31591161014b5780634800d97f116101255780634800d97f146102835780634ed2b8ac146102aa5780635886e7c1146102b25780635ddfbc5b146102c557600080fd5b8063183b31591461025557806322110c9d1461025d5780632ab0aabb1461027057600080fd5b8063020d5170146101935780630854dc45146101b15780630910a510146101d257806309382758146101da578063117803e3146101ef578063131e190a1461022e575b600080fd5b61019b6103b8565b6040516101a89190611798565b60405180910390f35b6101c46101bf3660046117ab565b610501565b6040519081526020016101a8565b6101c46105ee565b6101ed6101e83660046117ab565b6106af565b005b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101a8565b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6101c46107fe565b6101ed61026b3660046117ab565b61088f565b6101ed61027e36600461184a565b6109f0565b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6101c4610a47565b6101c46102c03660046118f7565b610b01565b6101c4600281565b6101ed6102db3660046117ab565b610bec565b6101ed6102ee3660046117ab565b610cbd565b6101c46103013660046117ab565b610d80565b6101c4600a81565b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6101ed610e8f565b6101c4610f4e565b6101c4610f68565b6101c4610fbf565b6101ed61036336600461184a565b6110f4565b6101c4611146565b610378611160565b604080519687526020870195909552938501929092526060840152608083015260a082015260c0016101a8565b6101c46103b3366004611914565b611208565b6040516335ea6a7560e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a759060240161018060405180830381865afa158015610445573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046991906119c9565b60408051600280825260608201835292935091906020830190803683370190505091508060e00151826000815181106104a4576104a4611abc565b60200260200101906001600160a01b031690816001600160a01b031681525050806101200151826001815181106104dd576104dd611abc565b60200260200101906001600160a01b031690816001600160a01b0316815250505090565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105545760405162461bcd60e51b815260040161054b90611ad2565b60405180910390fd5b6040516370a0823160e01b81523360048201526105e6907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa1580156105bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e09190611af5565b83611208565b90505b919050565b6000806105f9611160565b50505092505050610608610fbf565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610666573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061068a9190611b0e565b61069590600a611c26565b61069f9083611c35565b6106a99190611c4c565b91505090565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106f75760405162461bcd60e51b815260040161054b90611ad2565b61074b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000167f0000000000000000000000000000000000000000000000000000000000000000836112ef565b60405163e8eda9df60e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052306044830152600060648301527f0000000000000000000000000000000000000000000000000000000000000000169063e8eda9df906084015b600060405180830381600087803b1580156107e357600080fd5b505af11580156107f7573d6000803e3d6000fd5b5050505050565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a08231906024015b602060405180830381865afa158015610866573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061088a9190611af5565b905090565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146108d75760405162461bcd60e51b815260040161054b90611ad2565b61092b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000167f0000000000000000000000000000000000000000000000000000000000000000836112ef565b60405163573ade8160e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052600260448301523060648301527f0000000000000000000000000000000000000000000000000000000000000000169063573ade81906084015b6020604051808303816000875af11580156109c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ec9190611af5565b5050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610a385760405162461bcd60e51b815260040161054b90611ad2565b610a42828261137f565b505050565b60405163c44b11f760e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260009182917f0000000000000000000000000000000000000000000000000000000000000000169063c44b11f790602401602060405180830381865afa158015610ad2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610af69190611c6e565b5161ffff1692915050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b4b5760405162461bcd60e51b815260040161054b90611ad2565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa158015610b92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb69190611af5565b90506105e66001600160a01b0384167f0000000000000000000000000000000000000000000000000000000000000000836113f5565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c345760405162461bcd60e51b815260040161054b90611ad2565b60405163a415bcad60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820183905260026044830152600060648301523060848301527f0000000000000000000000000000000000000000000000000000000000000000169063a415bcad9060a4016107c9565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610d055760405162461bcd60e51b815260040161054b90611ad2565b604051631a4ca37b60e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390523060448301527f000000000000000000000000000000000000000000000000000000000000000016906369328dec906064016109a9565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610dca5760405162461bcd60e51b815260040161054b90611ad2565b6000610dd4611160565b5094505050505060005b8381108015610df457506000610df2610f4e565b115b15610e4457610e27600a83610e076105ee565b610e1390612710611c35565b610e1d9190611c4c565b6102ee9190611c8a565b610e3261026b6107fe565b80610e3c81611c9d565b915050610dde565b50610e4d610f4e565b600003610e5f57610e5f600019610cbd565b610e887f0000000000000000000000000000000000000000000000000000000000000000610b01565b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633111e7b3610ec66103b8565b6000197f00000000000000000000000000000000000000000000000000000000000000006040518463ffffffff1660e01b8152600401610f0893929190611cb6565b6020604051808303816000875af1158015610f27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f4b9190611af5565b50565b600080610f59611160565b50505050915050610608610fbf565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638b599f26610fa16103b8565b306040518363ffffffff1660e01b8152600401610849929190611ce9565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fe65acfe6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561101f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110439190611d13565b6001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611080573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a49190611d13565b60405163b3596f0760e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152919091169063b3596f0790602401610849565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461113c5760405162461bcd60e51b815260040161054b90611ad2565b610a428282611454565b600080611151611160565b50505050509050610608610fbf565b604051632fe4a15f60e21b8152306004820152600090819081908190819081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063bf92857c9060240160c060405180830381865afa1580156111d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111f59190611d30565b949b939a50919850965094509092509050565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146112525760405162461bcd60e51b815260040161054b90611ad2565b821561128d5761128d6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333086611462565b60006112976107fe565b11156112a8576112a86101e86107fe565b60005b828110156112dd576112ca600a6112c06105ee565b6102db9190611c8a565b6112d56101e86107fe565b6001016112ab565b506112e66105ee565b90505b92915050565b604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301526000919085169063dd62ed3e90604401602060405180830381865afa15801561133f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113639190611af5565b905061137984846113748585611d7a565b61149b565b50505050565b6060600080846001600160a01b03168460405161139c9190611d8d565b600060405180830381855af49150503d80600081146113d7576040519150601f19603f3d011682016040523d82523d6000602084013e6113dc565b606091505b50915091506113ec85838361152b565b95945050505050565b6040516001600160a01b03838116602483015260448201839052610a4291859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611587565b60606112e6838360006115ea565b6040516001600160a01b0384811660248301528381166044830152606482018390526113799186918216906323b872dd90608401611422565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b1790526114ec8482611687565b611379576040516001600160a01b0384811660248301526000604483015261152191869182169063095ea7b390606401611422565b6113798482611587565b6060826115405761153b8261172a565b610e88565b815115801561155757506001600160a01b0384163b155b1561158057604051639996b31560e01b81526001600160a01b038516600482015260240161054b565b5092915050565b600061159c6001600160a01b03841683611454565b905080516000141580156115c15750808060200190518101906115bf9190611dbc565b155b15610a4257604051635274afe760e01b81526001600160a01b038416600482015260240161054b565b60608147101561160f5760405163cd78605960e01b815230600482015260240161054b565b600080856001600160a01b0316848660405161162b9190611d8d565b60006040518083038185875af1925050503d8060008114611668576040519150601f19603f3d011682016040523d82523d6000602084013e61166d565b606091505b509150915061167d86838361152b565b9695505050505050565b6000806000846001600160a01b0316846040516116a49190611d8d565b6000604051808303816000865af19150503d80600081146116e1576040519150601f19603f3d011682016040523d82523d6000602084013e6116e6565b606091505b50915091508180156117105750805115806117105750808060200190518101906117109190611dbc565b80156113ec5750505050506001600160a01b03163b151590565b80511561173a5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b600081518084526020840193506020830160005b8281101561178e5781516001600160a01b0316865260209586019590910190600101611767565b5093949350505050565b6020815260006112e66020830184611753565b6000602082840312156117bd57600080fd5b5035919050565b6001600160a01b0381168114610f4b57600080fd5b634e487b7160e01b600052604160045260246000fd5b604051610180810167ffffffffffffffff81118282101715611813576118136117d9565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611842576118426117d9565b604052919050565b6000806040838503121561185d57600080fd5b8235611868816117c4565b9150602083013567ffffffffffffffff81111561188457600080fd5b8301601f8101851361189557600080fd5b803567ffffffffffffffff8111156118af576118af6117d9565b6118c2601f8201601f1916602001611819565b8181528660208385010111156118d757600080fd5b816020840160208301376000602083830101528093505050509250929050565b60006020828403121561190957600080fd5b8135610e88816117c4565b6000806040838503121561192757600080fd5b50508035926020909101359150565b60006020828403121561194857600080fd5b6040516020810167ffffffffffffffff8111828210171561196b5761196b6117d9565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff811681146105e957600080fd5b805164ffffffffff811681146105e957600080fd5b80516105e9816117c4565b805160ff811681146105e957600080fd5b60006101808284031280156119dd57600080fd5b506119e66117ef565b6119f08484611936565b81526119fe60208401611978565b6020820152611a0f60408401611978565b6040820152611a2060608401611978565b6060820152611a3160808401611978565b6080820152611a4260a08401611978565b60a0820152611a5360c08401611998565b60c0820152611a6460e084016119ad565b60e0820152611a7661010084016119ad565b610100820152611a8961012084016119ad565b610120820152611a9c61014084016119ad565b610140820152611aaf61016084016119b8565b6101608201529392505050565b634e487b7160e01b600052603260045260246000fd5b60208082526009908201526837b7363ca7bbb732b960b91b604082015260600190565b600060208284031215611b0757600080fd5b5051919050565b600060208284031215611b2057600080fd5b6112e6826119b8565b634e487b7160e01b600052601160045260246000fd5b6001815b6001841115611b7a57808504811115611b5e57611b5e611b29565b6001841615611b6c57908102905b60019390931c928002611b43565b935093915050565b600082611b91575060016112e9565b81611b9e575060006112e9565b8160018114611bb45760028114611bbe57611bda565b60019150506112e9565b60ff841115611bcf57611bcf611b29565b50506001821b6112e9565b5060208310610133831016604e8410600b8410161715611bfd575081810a6112e9565b611c0a6000198484611b3f565b8060001904821115611c1e57611c1e611b29565b029392505050565b60006112e660ff841683611b82565b80820281158282048414176112e9576112e9611b29565b600082611c6957634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215611c8057600080fd5b6112e68383611936565b818103818111156112e9576112e9611b29565b600060018201611caf57611caf611b29565b5060010190565b606081526000611cc96060830186611753565b6020830194909452506001600160a01b0391909116604090910152919050565b604081526000611cfc6040830185611753565b905060018060a01b03831660208301529392505050565b600060208284031215611d2557600080fd5b8151610e88816117c4565b60008060008060008060c08789031215611d4957600080fd5b50508451602086015160408701516060880151608089015160a090990151939a929950909790965094509092509050565b808201808211156112e9576112e9611b29565b6000825160005b81811015611dae5760208186018101518583015201611d94565b506000920191825250919050565b600060208284031215611dce57600080fd5b81518015158114610e8857600080fdfea2646970667358221220509b54f2bcfc696ffbd905adb3c701ed4ba01fe10c9a43224afb0a7a9bcb540e64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\0`@R4\x80\x15a\0\x11W`\0\x80\xFD[P`@Qa \xCD8\x03\x80a \xCD\x839\x81\x01`@\x81\x90Ra\x000\x91a\x01\"V[\x83`\x01`\x01`\xA0\x1B\x03\x81\x16a\0vW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x07`$\x82\x01Rf\x06\xF7v\xE6W\"\x03`\xCC\x1B`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`\x80R\x83\x16\x15\x80\x15\x90a\0\x9CWP`\x01`\x01`\xA0\x1B\x03\x82\x16\x15\x15[\x80\x15a\0\xB0WP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x15[a\0\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rh\x06\x16FG&W72\x03`\xBC\x1B`D\x82\x01R`d\x01a\0mV[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16`\xA0R\x90\x82\x16`\xC0R\x16`\xE0RPa\x01vV[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x01\x1DW`\0\x80\xFD[\x91\x90PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\x018W`\0\x80\xFD[a\x01A\x85a\x01\x06V[\x93Pa\x01O` \x86\x01a\x01\x06V[\x92Pa\x01]`@\x86\x01a\x01\x06V[\x91Pa\x01k``\x86\x01a\x01\x06V[\x90P\x92\x95\x91\x94P\x92PV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x1E\x14a\x02\xB9`\09`\0\x81\x81a\x023\x01R\x81\x81a\x0E\x91\x01Ra\x0Fl\x01R`\0\x81\x81a\x03\x13\x01R\x81\x81a\x03\xFD\x01R\x81\x81a\x07&\x01R\x81\x81a\x07\x9E\x01R\x81\x81a\t\x06\x01R\x81\x81a\t~\x01R\x81\x81a\n\x8B\x01R\x81\x81a\x0C\x8E\x01R\x81\x81a\rQ\x01R\x81\x81a\x0F\xC3\x01Ra\x11\x8A\x01R`\0\x81\x81a\x02\x88\x01R\x81\x81a\x03\xCF\x01R\x81\x81a\x05m\x01R\x81\x81a\x06\n\x01R\x81\x81a\x07\x04\x01R\x81\x81a\x07b\x01R\x81\x81a\x08\x16\x01R\x81\x81a\x08\xE4\x01R\x81\x81a\tB\x01R\x81\x81a\n^\x01R\x81\x81a\x0CK\x01R\x81\x81a\r\x1C\x01R\x81\x81a\x0Ed\x01R\x81\x81a\x10\xBB\x01Ra\x12e\x01R`\0\x81\x81a\x01\xF4\x01R\x81\x81a\x05\x0E\x01R\x81\x81a\x06\xBA\x01R\x81\x81a\x08\x9A\x01R\x81\x81a\t\xFB\x01R\x81\x81a\x0B\x0E\x01R\x81\x81a\x0B\xC7\x01R\x81\x81a\x0B\xF7\x01R\x81\x81a\x0C\xC8\x01R\x81\x81a\r\x8D\x01R\x81\x81a\x0E\xCB\x01R\x81\x81a\x10\xFF\x01Ra\x12\x15\x01Ra\x1E\x14`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x01\x8EW`\x005`\xE0\x1C\x80cc\xE5K\xB1\x11a\0\xDEW\x80c\xCA e\x91\x11a\0\x97W\x80c\xE7\x8Ds\xAD\x11a\0qW\x80c\xE7\x8Ds\xAD\x14a\x03UW\x80c\xE8\xC9D\xE6\x14a\x03hW\x80c\xE8\xF3yc\x14a\x03pW\x80c\xFB\xDF{E\x14a\x03\xA5W`\0\x80\xFD[\x80c\xCA e\x91\x14a\x03=W\x80c\xD9b\x1F\x9E\x14a\x03EW\x80c\xE5O\x08\x80\x14a\x03MW`\0\x80\xFD[\x80cc\xE5K\xB1\x14a\x02\xCDW\x80cv0s\x13\x14a\x02\xE0W\x80cx\xDC\x90Y\x14a\x02\xF3W\x80c\x8A\x0C\xCFl\x14a\x03\x06W\x80c\xB4\xDC\xFCw\x14a\x03\x0EW\x80c\xBD4_\x14\x14a\x035W`\0\x80\xFD[\x80c\x18;1Y\x11a\x01KW\x80cH\0\xD9\x7F\x11a\x01%W\x80cH\0\xD9\x7F\x14a\x02\x83W\x80cN\xD2\xB8\xAC\x14a\x02\xAAW\x80cX\x86\xE7\xC1\x14a\x02\xB2W\x80c]\xDF\xBC[\x14a\x02\xC5W`\0\x80\xFD[\x80c\x18;1Y\x14a\x02UW\x80c\"\x11\x0C\x9D\x14a\x02]W\x80c*\xB0\xAA\xBB\x14a\x02pW`\0\x80\xFD[\x80c\x02\rQp\x14a\x01\x93W\x80c\x08T\xDCE\x14a\x01\xB1W\x80c\t\x10\xA5\x10\x14a\x01\xD2W\x80c\t8'X\x14a\x01\xDAW\x80c\x11x\x03\xE3\x14a\x01\xEFW\x80c\x13\x1E\x19\n\x14a\x02.W[`\0\x80\xFD[a\x01\x9Ba\x03\xB8V[`@Qa\x01\xA8\x91\x90a\x17\x98V[`@Q\x80\x91\x03\x90\xF3[a\x01\xC4a\x01\xBF6`\x04a\x17\xABV[a\x05\x01V[`@Q\x90\x81R` \x01a\x01\xA8V[a\x01\xC4a\x05\xEEV[a\x01\xEDa\x01\xE86`\x04a\x17\xABV[a\x06\xAFV[\0[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xA8V[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x01\xC4a\x07\xFEV[a\x01\xEDa\x02k6`\x04a\x17\xABV[a\x08\x8FV[a\x01\xEDa\x02~6`\x04a\x18JV[a\t\xF0V[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x01\xC4a\nGV[a\x01\xC4a\x02\xC06`\x04a\x18\xF7V[a\x0B\x01V[a\x01\xC4`\x02\x81V[a\x01\xEDa\x02\xDB6`\x04a\x17\xABV[a\x0B\xECV[a\x01\xEDa\x02\xEE6`\x04a\x17\xABV[a\x0C\xBDV[a\x01\xC4a\x03\x016`\x04a\x17\xABV[a\r\x80V[a\x01\xC4`\n\x81V[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x01\xEDa\x0E\x8FV[a\x01\xC4a\x0FNV[a\x01\xC4a\x0FhV[a\x01\xC4a\x0F\xBFV[a\x01\xEDa\x03c6`\x04a\x18JV[a\x10\xF4V[a\x01\xC4a\x11FV[a\x03xa\x11`V[`@\x80Q\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R`\xA0\x82\x01R`\xC0\x01a\x01\xA8V[a\x01\xC4a\x03\xB36`\x04a\x19\x14V[a\x12\x08V[`@Qc5\xEAju`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R``\x91`\0\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c5\xEAju\x90`$\x01a\x01\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04EW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04i\x91\x90a\x19\xC9V[`@\x80Q`\x02\x80\x82R``\x82\x01\x83R\x92\x93P\x91\x90` \x83\x01\x90\x806\x837\x01\x90PP\x91P\x80`\xE0\x01Q\x82`\0\x81Q\x81\x10a\x04\xA4Wa\x04\xA4a\x1A\xBCV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPP\x80a\x01 \x01Q\x82`\x01\x81Q\x81\x10a\x04\xDDWa\x04\xDDa\x1A\xBCV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPPP\x90V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x05TW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Q\x80\x91\x03\x90\xFD[`@Qcp\xA0\x821`\xE0\x1B\x81R3`\x04\x82\x01Ra\x05\xE6\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xBCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xE0\x91\x90a\x1A\xF5V[\x83a\x12\x08V[\x90P[\x91\x90PV[`\0\x80a\x05\xF9a\x11`V[PPP\x92PPPa\x06\x08a\x0F\xBFV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06fW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x8A\x91\x90a\x1B\x0EV[a\x06\x95\x90`\na\x1C&V[a\x06\x9F\x90\x83a\x1C5V[a\x06\xA9\x91\x90a\x1CLV[\x91PP\x90V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x06\xF7W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\x07K`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x12\xEFV[`@Qc\xE8\xED\xA9\xDF`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R`\0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xE8\xED\xA9\xDF\x90`\x84\x01[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x07\xE3W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x07\xF7W=`\0\x80>=`\0\xFD[PPPPPV[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cp\xA0\x821\x90`$\x01[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08fW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x8A\x91\x90a\x1A\xF5V[\x90P\x90V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x08\xD7W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\t+`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x12\xEFV[`@QcW:\xDE\x81`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cW:\xDE\x81\x90`\x84\x01[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\t\xC8W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xEC\x91\x90a\x1A\xF5V[PPV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\n8W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\nB\x82\x82a\x13\x7FV[PPPV[`@Qc\xC4K\x11\xF7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`\0\x91\x82\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xC4K\x11\xF7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xD2W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xF6\x91\x90a\x1CnV[Qa\xFF\xFF\x16\x92\x91PPV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0BKW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xB6\x91\x90a\x1A\xF5V[\x90Pa\x05\xE6`\x01`\x01`\xA0\x1B\x03\x84\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x13\xF5V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0C4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Qc\xA4\x15\xBC\xAD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R`\0`d\x83\x01R0`\x84\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA4\x15\xBC\xAD\x90`\xA4\x01a\x07\xC9V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\r\x05W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Qc\x1AL\xA3{`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90ci2\x8D\xEC\x90`d\x01a\t\xA9V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\r\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`\0a\r\xD4a\x11`V[P\x94PPPPP`\0[\x83\x81\x10\x80\x15a\r\xF4WP`\0a\r\xF2a\x0FNV[\x11[\x15a\x0EDWa\x0E'`\n\x83a\x0E\x07a\x05\xEEV[a\x0E\x13\x90a'\x10a\x1C5V[a\x0E\x1D\x91\x90a\x1CLV[a\x02\xEE\x91\x90a\x1C\x8AV[a\x0E2a\x02ka\x07\xFEV[\x80a\x0E<\x81a\x1C\x9DV[\x91PPa\r\xDEV[Pa\x0EMa\x0FNV[`\0\x03a\x0E_Wa\x0E_`\0\x19a\x0C\xBDV[a\x0E\x88\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x0B\x01V[\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c1\x11\xE7\xB3a\x0E\xC6a\x03\xB8V[`\0\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0F\x08\x93\x92\x91\x90a\x1C\xB6V[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x0F'W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0FK\x91\x90a\x1A\xF5V[PV[`\0\x80a\x0FYa\x11`V[PPPP\x91PPa\x06\x08a\x0F\xBFV[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x8BY\x9F&a\x0F\xA1a\x03\xB8V[0`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x08I\x92\x91\x90a\x1C\xE9V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xFEe\xAC\xFE`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x1FW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10C\x91\x90a\x1D\x13V[`\x01`\x01`\xA0\x1B\x03\x16c\xFC\xA5\x13\xA8`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x80W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xA4\x91\x90a\x1D\x13V[`@Qc\xB3Yo\x07`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R\x91\x90\x91\x16\x90c\xB3Yo\x07\x90`$\x01a\x08IV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x11<W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\nB\x82\x82a\x14TV[`\0\x80a\x11Qa\x11`V[PPPPP\x90Pa\x06\x08a\x0F\xBFV[`@Qc/\xE4\xA1_`\xE2\x1B\x81R0`\x04\x82\x01R`\0\x90\x81\x90\x81\x90\x81\x90\x81\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xBF\x92\x85|\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11\xD1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\xF5\x91\x90a\x1D0V[\x94\x9B\x93\x9AP\x91\x98P\x96P\x94P\x90\x92P\x90PV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x12RW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[\x82\x15a\x12\x8DWa\x12\x8D`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1630\x86a\x14bV[`\0a\x12\x97a\x07\xFEV[\x11\x15a\x12\xA8Wa\x12\xA8a\x01\xE8a\x07\xFEV[`\0[\x82\x81\x10\x15a\x12\xDDWa\x12\xCA`\na\x12\xC0a\x05\xEEV[a\x02\xDB\x91\x90a\x1C\x8AV[a\x12\xD5a\x01\xE8a\x07\xFEV[`\x01\x01a\x12\xABV[Pa\x12\xE6a\x05\xEEV[\x90P[\x92\x91PPV[`@Qcn\xB1v\x9F`\xE1\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`\0\x91\x90\x85\x16\x90c\xDDb\xED>\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13?W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13c\x91\x90a\x1A\xF5V[\x90Pa\x13y\x84\x84a\x13t\x85\x85a\x1DzV[a\x14\x9BV[PPPPV[```\0\x80\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x13\x9C\x91\x90a\x1D\x8DV[`\0`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80`\0\x81\x14a\x13\xD7W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x13\xDCV[``\x91P[P\x91P\x91Pa\x13\xEC\x85\x83\x83a\x15+V[\x95\x94PPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`D\x82\x01\x83\x90Ra\nB\x91\x85\x91\x82\x16\x90c\xA9\x05\x9C\xBB\x90`d\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x91P`\xE0\x1B` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x83\x81\x83\x16\x17\x83RPPPPa\x15\x87V[``a\x12\xE6\x83\x83`\0a\x15\xEAV[`@Q`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`$\x83\x01R\x83\x81\x16`D\x83\x01R`d\x82\x01\x83\x90Ra\x13y\x91\x86\x91\x82\x16\x90c#\xB8r\xDD\x90`\x84\x01a\x14\"V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90Ra\x14\xEC\x84\x82a\x16\x87V[a\x13yW`@Q`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`$\x83\x01R`\0`D\x83\x01Ra\x15!\x91\x86\x91\x82\x16\x90c\t^\xA7\xB3\x90`d\x01a\x14\"V[a\x13y\x84\x82a\x15\x87V[``\x82a\x15@Wa\x15;\x82a\x17*V[a\x0E\x88V[\x81Q\x15\x80\x15a\x15WWP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x15\x80W`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x05KV[P\x92\x91PPV[`\0a\x15\x9C`\x01`\x01`\xA0\x1B\x03\x84\x16\x83a\x14TV[\x90P\x80Q`\0\x14\x15\x80\x15a\x15\xC1WP\x80\x80` \x01\x90Q\x81\x01\x90a\x15\xBF\x91\x90a\x1D\xBCV[\x15[\x15a\nBW`@QcRt\xAF\xE7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04\x82\x01R`$\x01a\x05KV[``\x81G\x10\x15a\x16\x0FW`@Qc\xCDx`Y`\xE0\x1B\x81R0`\x04\x82\x01R`$\x01a\x05KV[`\0\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x84\x86`@Qa\x16+\x91\x90a\x1D\x8DV[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x16hW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x16mV[``\x91P[P\x91P\x91Pa\x16}\x86\x83\x83a\x15+V[\x96\x95PPPPPPV[`\0\x80`\0\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x16\xA4\x91\x90a\x1D\x8DV[`\0`@Q\x80\x83\x03\x81`\0\x86Z\xF1\x91PP=\x80`\0\x81\x14a\x16\xE1W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x16\xE6V[``\x91P[P\x91P\x91P\x81\x80\x15a\x17\x10WP\x80Q\x15\x80a\x17\x10WP\x80\x80` \x01\x90Q\x81\x01\x90a\x17\x10\x91\x90a\x1D\xBCV[\x80\x15a\x13\xECWPPPPP`\x01`\x01`\xA0\x1B\x03\x16;\x15\x15\x90V[\x80Q\x15a\x17:W\x80Q\x80\x82` \x01\xFD[`@Qc\n\x12\xF5!`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01`\0[\x82\x81\x10\x15a\x17\x8EW\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x17gV[P\x93\x94\x93PPPPV[` \x81R`\0a\x12\xE6` \x83\x01\x84a\x17SV[`\0` \x82\x84\x03\x12\x15a\x17\xBDW`\0\x80\xFD[P5\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0FKW`\0\x80\xFD[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`@Qa\x01\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18\x13Wa\x18\x13a\x17\xD9V[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18BWa\x18Ba\x17\xD9V[`@R\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x18]W`\0\x80\xFD[\x825a\x18h\x81a\x17\xC4V[\x91P` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\x84W`\0\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x18\x95W`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\xAFWa\x18\xAFa\x17\xD9V[a\x18\xC2`\x1F\x82\x01`\x1F\x19\x16` \x01a\x18\x19V[\x81\x81R\x86` \x83\x85\x01\x01\x11\x15a\x18\xD7W`\0\x80\xFD[\x81` \x84\x01` \x83\x017`\0` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15a\x19\tW`\0\x80\xFD[\x815a\x0E\x88\x81a\x17\xC4V[`\0\x80`@\x83\x85\x03\x12\x15a\x19'W`\0\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[`\0` \x82\x84\x03\x12\x15a\x19HW`\0\x80\xFD[`@Q` \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x19kWa\x19ka\x17\xD9V[`@R\x91Q\x82RP\x91\x90PV[\x80Qo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xE9W`\0\x80\xFD[\x80Qd\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xE9W`\0\x80\xFD[\x80Qa\x05\xE9\x81a\x17\xC4V[\x80Q`\xFF\x81\x16\x81\x14a\x05\xE9W`\0\x80\xFD[`\0a\x01\x80\x82\x84\x03\x12\x80\x15a\x19\xDDW`\0\x80\xFD[Pa\x19\xE6a\x17\xEFV[a\x19\xF0\x84\x84a\x196V[\x81Ra\x19\xFE` \x84\x01a\x19xV[` \x82\x01Ra\x1A\x0F`@\x84\x01a\x19xV[`@\x82\x01Ra\x1A ``\x84\x01a\x19xV[``\x82\x01Ra\x1A1`\x80\x84\x01a\x19xV[`\x80\x82\x01Ra\x1AB`\xA0\x84\x01a\x19xV[`\xA0\x82\x01Ra\x1AS`\xC0\x84\x01a\x19\x98V[`\xC0\x82\x01Ra\x1Ad`\xE0\x84\x01a\x19\xADV[`\xE0\x82\x01Ra\x1Ava\x01\0\x84\x01a\x19\xADV[a\x01\0\x82\x01Ra\x1A\x89a\x01 \x84\x01a\x19\xADV[a\x01 \x82\x01Ra\x1A\x9Ca\x01@\x84\x01a\x19\xADV[a\x01@\x82\x01Ra\x1A\xAFa\x01`\x84\x01a\x19\xB8V[a\x01`\x82\x01R\x93\x92PPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[` \x80\x82R`\t\x90\x82\x01Rh7\xB76<\xA7\xBB\xB72\xB9`\xB9\x1B`@\x82\x01R``\x01\x90V[`\0` \x82\x84\x03\x12\x15a\x1B\x07W`\0\x80\xFD[PQ\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x1B W`\0\x80\xFD[a\x12\xE6\x82a\x19\xB8V[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\x01\x81[`\x01\x84\x11\x15a\x1BzW\x80\x85\x04\x81\x11\x15a\x1B^Wa\x1B^a\x1B)V[`\x01\x84\x16\x15a\x1BlW\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a\x1BCV[\x93P\x93\x91PPV[`\0\x82a\x1B\x91WP`\x01a\x12\xE9V[\x81a\x1B\x9EWP`\0a\x12\xE9V[\x81`\x01\x81\x14a\x1B\xB4W`\x02\x81\x14a\x1B\xBEWa\x1B\xDAV[`\x01\x91PPa\x12\xE9V[`\xFF\x84\x11\x15a\x1B\xCFWa\x1B\xCFa\x1B)V[PP`\x01\x82\x1Ba\x12\xE9V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x1B\xFDWP\x81\x81\na\x12\xE9V[a\x1C\n`\0\x19\x84\x84a\x1B?V[\x80`\0\x19\x04\x82\x11\x15a\x1C\x1EWa\x1C\x1Ea\x1B)V[\x02\x93\x92PPPV[`\0a\x12\xE6`\xFF\x84\x16\x83a\x1B\x82V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x12\xE9Wa\x12\xE9a\x1B)V[`\0\x82a\x1CiWcNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[P\x04\x90V[`\0` \x82\x84\x03\x12\x15a\x1C\x80W`\0\x80\xFD[a\x12\xE6\x83\x83a\x196V[\x81\x81\x03\x81\x81\x11\x15a\x12\xE9Wa\x12\xE9a\x1B)V[`\0`\x01\x82\x01a\x1C\xAFWa\x1C\xAFa\x1B)V[P`\x01\x01\x90V[``\x81R`\0a\x1C\xC9``\x83\x01\x86a\x17SV[` \x83\x01\x94\x90\x94RP`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`@\x90\x91\x01R\x91\x90PV[`@\x81R`\0a\x1C\xFC`@\x83\x01\x85a\x17SV[\x90P`\x01\x80`\xA0\x1B\x03\x83\x16` \x83\x01R\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15a\x1D%W`\0\x80\xFD[\x81Qa\x0E\x88\x81a\x17\xC4V[`\0\x80`\0\x80`\0\x80`\xC0\x87\x89\x03\x12\x15a\x1DIW`\0\x80\xFD[PP\x84Q` \x86\x01Q`@\x87\x01Q``\x88\x01Q`\x80\x89\x01Q`\xA0\x90\x99\x01Q\x93\x9A\x92\x99P\x90\x97\x90\x96P\x94P\x90\x92P\x90PV[\x80\x82\x01\x80\x82\x11\x15a\x12\xE9Wa\x12\xE9a\x1B)V[`\0\x82Q`\0[\x81\x81\x10\x15a\x1D\xAEW` \x81\x86\x01\x81\x01Q\x85\x83\x01R\x01a\x1D\x94V[P`\0\x92\x01\x91\x82RP\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x1D\xCEW`\0\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x0E\x88W`\0\x80\xFD\xFE\xA2dipfsX\"\x12 P\x9BT\xF2\xBC\xFCio\xFB\xD9\x05\xAD\xB3\xC7\x01\xEDK\xA0\x1F\xE1\x0C\x9AC\"J\xFB\nz\x9B\xCBT\x0EdsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b506004361061018e5760003560e01c806363e54bb1116100de578063ca20659111610097578063e78d73ad11610071578063e78d73ad14610355578063e8c944e614610368578063e8f3796314610370578063fbdf7b45146103a557600080fd5b8063ca2065911461033d578063d9621f9e14610345578063e54f08801461034d57600080fd5b806363e54bb1146102cd57806376307313146102e057806378dc9059146102f35780638a0ccf6c14610306578063b4dcfc771461030e578063bd345f141461033557600080fd5b8063183b31591161014b5780634800d97f116101255780634800d97f146102835780634ed2b8ac146102aa5780635886e7c1146102b25780635ddfbc5b146102c557600080fd5b8063183b31591461025557806322110c9d1461025d5780632ab0aabb1461027057600080fd5b8063020d5170146101935780630854dc45146101b15780630910a510146101d257806309382758146101da578063117803e3146101ef578063131e190a1461022e575b600080fd5b61019b6103b8565b6040516101a89190611798565b60405180910390f35b6101c46101bf3660046117ab565b610501565b6040519081526020016101a8565b6101c46105ee565b6101ed6101e83660046117ab565b6106af565b005b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101a8565b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6101c46107fe565b6101ed61026b3660046117ab565b61088f565b6101ed61027e36600461184a565b6109f0565b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6101c4610a47565b6101c46102c03660046118f7565b610b01565b6101c4600281565b6101ed6102db3660046117ab565b610bec565b6101ed6102ee3660046117ab565b610cbd565b6101c46103013660046117ab565b610d80565b6101c4600a81565b6102167f000000000000000000000000000000000000000000000000000000000000000081565b6101ed610e8f565b6101c4610f4e565b6101c4610f68565b6101c4610fbf565b6101ed61036336600461184a565b6110f4565b6101c4611146565b610378611160565b604080519687526020870195909552938501929092526060840152608083015260a082015260c0016101a8565b6101c46103b3366004611914565b611208565b6040516335ea6a7560e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a759060240161018060405180830381865afa158015610445573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061046991906119c9565b60408051600280825260608201835292935091906020830190803683370190505091508060e00151826000815181106104a4576104a4611abc565b60200260200101906001600160a01b031690816001600160a01b031681525050806101200151826001815181106104dd576104dd611abc565b60200260200101906001600160a01b031690816001600160a01b0316815250505090565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105545760405162461bcd60e51b815260040161054b90611ad2565b60405180910390fd5b6040516370a0823160e01b81523360048201526105e6907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa1580156105bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e09190611af5565b83611208565b90505b919050565b6000806105f9611160565b50505092505050610608610fbf565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610666573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061068a9190611b0e565b61069590600a611c26565b61069f9083611c35565b6106a99190611c4c565b91505090565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106f75760405162461bcd60e51b815260040161054b90611ad2565b61074b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000167f0000000000000000000000000000000000000000000000000000000000000000836112ef565b60405163e8eda9df60e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052306044830152600060648301527f0000000000000000000000000000000000000000000000000000000000000000169063e8eda9df906084015b600060405180830381600087803b1580156107e357600080fd5b505af11580156107f7573d6000803e3d6000fd5b5050505050565b6040516370a0823160e01b81523060048201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a08231906024015b602060405180830381865afa158015610866573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061088a9190611af5565b905090565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146108d75760405162461bcd60e51b815260040161054b90611ad2565b61092b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000167f0000000000000000000000000000000000000000000000000000000000000000836112ef565b60405163573ade8160e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052600260448301523060648301527f0000000000000000000000000000000000000000000000000000000000000000169063573ade81906084015b6020604051808303816000875af11580156109c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ec9190611af5565b5050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610a385760405162461bcd60e51b815260040161054b90611ad2565b610a42828261137f565b505050565b60405163c44b11f760e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260009182917f0000000000000000000000000000000000000000000000000000000000000000169063c44b11f790602401602060405180830381865afa158015610ad2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610af69190611c6e565b5161ffff1692915050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b4b5760405162461bcd60e51b815260040161054b90611ad2565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa158015610b92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb69190611af5565b90506105e66001600160a01b0384167f0000000000000000000000000000000000000000000000000000000000000000836113f5565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c345760405162461bcd60e51b815260040161054b90611ad2565b60405163a415bcad60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820183905260026044830152600060648301523060848301527f0000000000000000000000000000000000000000000000000000000000000000169063a415bcad9060a4016107c9565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610d055760405162461bcd60e51b815260040161054b90611ad2565b604051631a4ca37b60e21b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390523060448301527f000000000000000000000000000000000000000000000000000000000000000016906369328dec906064016109a9565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610dca5760405162461bcd60e51b815260040161054b90611ad2565b6000610dd4611160565b5094505050505060005b8381108015610df457506000610df2610f4e565b115b15610e4457610e27600a83610e076105ee565b610e1390612710611c35565b610e1d9190611c4c565b6102ee9190611c8a565b610e3261026b6107fe565b80610e3c81611c9d565b915050610dde565b50610e4d610f4e565b600003610e5f57610e5f600019610cbd565b610e887f0000000000000000000000000000000000000000000000000000000000000000610b01565b9392505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316633111e7b3610ec66103b8565b6000197f00000000000000000000000000000000000000000000000000000000000000006040518463ffffffff1660e01b8152600401610f0893929190611cb6565b6020604051808303816000875af1158015610f27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f4b9190611af5565b50565b600080610f59611160565b50505050915050610608610fbf565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638b599f26610fa16103b8565b306040518363ffffffff1660e01b8152600401610849929190611ce9565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fe65acfe6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561101f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110439190611d13565b6001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611080573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a49190611d13565b60405163b3596f0760e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152919091169063b3596f0790602401610849565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461113c5760405162461bcd60e51b815260040161054b90611ad2565b610a428282611454565b600080611151611160565b50505050509050610608610fbf565b604051632fe4a15f60e21b8152306004820152600090819081908190819081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063bf92857c9060240160c060405180830381865afa1580156111d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111f59190611d30565b949b939a50919850965094509092509050565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146112525760405162461bcd60e51b815260040161054b90611ad2565b821561128d5761128d6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016333086611462565b60006112976107fe565b11156112a8576112a86101e86107fe565b60005b828110156112dd576112ca600a6112c06105ee565b6102db9190611c8a565b6112d56101e86107fe565b6001016112ab565b506112e66105ee565b90505b92915050565b604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301526000919085169063dd62ed3e90604401602060405180830381865afa15801561133f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113639190611af5565b905061137984846113748585611d7a565b61149b565b50505050565b6060600080846001600160a01b03168460405161139c9190611d8d565b600060405180830381855af49150503d80600081146113d7576040519150601f19603f3d011682016040523d82523d6000602084013e6113dc565b606091505b50915091506113ec85838361152b565b95945050505050565b6040516001600160a01b03838116602483015260448201839052610a4291859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611587565b60606112e6838360006115ea565b6040516001600160a01b0384811660248301528381166044830152606482018390526113799186918216906323b872dd90608401611422565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b1790526114ec8482611687565b611379576040516001600160a01b0384811660248301526000604483015261152191869182169063095ea7b390606401611422565b6113798482611587565b6060826115405761153b8261172a565b610e88565b815115801561155757506001600160a01b0384163b155b1561158057604051639996b31560e01b81526001600160a01b038516600482015260240161054b565b5092915050565b600061159c6001600160a01b03841683611454565b905080516000141580156115c15750808060200190518101906115bf9190611dbc565b155b15610a4257604051635274afe760e01b81526001600160a01b038416600482015260240161054b565b60608147101561160f5760405163cd78605960e01b815230600482015260240161054b565b600080856001600160a01b0316848660405161162b9190611d8d565b60006040518083038185875af1925050503d8060008114611668576040519150601f19603f3d011682016040523d82523d6000602084013e61166d565b606091505b509150915061167d86838361152b565b9695505050505050565b6000806000846001600160a01b0316846040516116a49190611d8d565b6000604051808303816000865af19150503d80600081146116e1576040519150601f19603f3d011682016040523d82523d6000602084013e6116e6565b606091505b50915091508180156117105750805115806117105750808060200190518101906117109190611dbc565b80156113ec5750505050506001600160a01b03163b151590565b80511561173a5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b600081518084526020840193506020830160005b8281101561178e5781516001600160a01b0316865260209586019590910190600101611767565b5093949350505050565b6020815260006112e66020830184611753565b6000602082840312156117bd57600080fd5b5035919050565b6001600160a01b0381168114610f4b57600080fd5b634e487b7160e01b600052604160045260246000fd5b604051610180810167ffffffffffffffff81118282101715611813576118136117d9565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611842576118426117d9565b604052919050565b6000806040838503121561185d57600080fd5b8235611868816117c4565b9150602083013567ffffffffffffffff81111561188457600080fd5b8301601f8101851361189557600080fd5b803567ffffffffffffffff8111156118af576118af6117d9565b6118c2601f8201601f1916602001611819565b8181528660208385010111156118d757600080fd5b816020840160208301376000602083830101528093505050509250929050565b60006020828403121561190957600080fd5b8135610e88816117c4565b6000806040838503121561192757600080fd5b50508035926020909101359150565b60006020828403121561194857600080fd5b6040516020810167ffffffffffffffff8111828210171561196b5761196b6117d9565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff811681146105e957600080fd5b805164ffffffffff811681146105e957600080fd5b80516105e9816117c4565b805160ff811681146105e957600080fd5b60006101808284031280156119dd57600080fd5b506119e66117ef565b6119f08484611936565b81526119fe60208401611978565b6020820152611a0f60408401611978565b6040820152611a2060608401611978565b6060820152611a3160808401611978565b6080820152611a4260a08401611978565b60a0820152611a5360c08401611998565b60c0820152611a6460e084016119ad565b60e0820152611a7661010084016119ad565b610100820152611a8961012084016119ad565b610120820152611a9c61014084016119ad565b610140820152611aaf61016084016119b8565b6101608201529392505050565b634e487b7160e01b600052603260045260246000fd5b60208082526009908201526837b7363ca7bbb732b960b91b604082015260600190565b600060208284031215611b0757600080fd5b5051919050565b600060208284031215611b2057600080fd5b6112e6826119b8565b634e487b7160e01b600052601160045260246000fd5b6001815b6001841115611b7a57808504811115611b5e57611b5e611b29565b6001841615611b6c57908102905b60019390931c928002611b43565b935093915050565b600082611b91575060016112e9565b81611b9e575060006112e9565b8160018114611bb45760028114611bbe57611bda565b60019150506112e9565b60ff841115611bcf57611bcf611b29565b50506001821b6112e9565b5060208310610133831016604e8410600b8410161715611bfd575081810a6112e9565b611c0a6000198484611b3f565b8060001904821115611c1e57611c1e611b29565b029392505050565b60006112e660ff841683611b82565b80820281158282048414176112e9576112e9611b29565b600082611c6957634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215611c8057600080fd5b6112e68383611936565b818103818111156112e9576112e9611b29565b600060018201611caf57611caf611b29565b5060010190565b606081526000611cc96060830186611753565b6020830194909452506001600160a01b0391909116604090910152919050565b604081526000611cfc6040830185611753565b905060018060a01b03831660208301529392505050565b600060208284031215611d2557600080fd5b8151610e88816117c4565b60008060008060008060c08789031215611d4957600080fd5b50508451602086015160408701516060880151608089015160a090990151939a929950909790965094509092509050565b808201808211156112e9576112e9611b29565b6000825160005b81811015611dae5760208186018101518583015201611d94565b506000920191825250919050565b600060208284031215611dce57600080fd5b81518015158114610e8857600080fdfea2646970667358221220509b54f2bcfc696ffbd905adb3c701ed4ba01fe10c9a43224afb0a7a9bcb540e64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x01\x8EW`\x005`\xE0\x1C\x80cc\xE5K\xB1\x11a\0\xDEW\x80c\xCA e\x91\x11a\0\x97W\x80c\xE7\x8Ds\xAD\x11a\0qW\x80c\xE7\x8Ds\xAD\x14a\x03UW\x80c\xE8\xC9D\xE6\x14a\x03hW\x80c\xE8\xF3yc\x14a\x03pW\x80c\xFB\xDF{E\x14a\x03\xA5W`\0\x80\xFD[\x80c\xCA e\x91\x14a\x03=W\x80c\xD9b\x1F\x9E\x14a\x03EW\x80c\xE5O\x08\x80\x14a\x03MW`\0\x80\xFD[\x80cc\xE5K\xB1\x14a\x02\xCDW\x80cv0s\x13\x14a\x02\xE0W\x80cx\xDC\x90Y\x14a\x02\xF3W\x80c\x8A\x0C\xCFl\x14a\x03\x06W\x80c\xB4\xDC\xFCw\x14a\x03\x0EW\x80c\xBD4_\x14\x14a\x035W`\0\x80\xFD[\x80c\x18;1Y\x11a\x01KW\x80cH\0\xD9\x7F\x11a\x01%W\x80cH\0\xD9\x7F\x14a\x02\x83W\x80cN\xD2\xB8\xAC\x14a\x02\xAAW\x80cX\x86\xE7\xC1\x14a\x02\xB2W\x80c]\xDF\xBC[\x14a\x02\xC5W`\0\x80\xFD[\x80c\x18;1Y\x14a\x02UW\x80c\"\x11\x0C\x9D\x14a\x02]W\x80c*\xB0\xAA\xBB\x14a\x02pW`\0\x80\xFD[\x80c\x02\rQp\x14a\x01\x93W\x80c\x08T\xDCE\x14a\x01\xB1W\x80c\t\x10\xA5\x10\x14a\x01\xD2W\x80c\t8'X\x14a\x01\xDAW\x80c\x11x\x03\xE3\x14a\x01\xEFW\x80c\x13\x1E\x19\n\x14a\x02.W[`\0\x80\xFD[a\x01\x9Ba\x03\xB8V[`@Qa\x01\xA8\x91\x90a\x17\x98V[`@Q\x80\x91\x03\x90\xF3[a\x01\xC4a\x01\xBF6`\x04a\x17\xABV[a\x05\x01V[`@Q\x90\x81R` \x01a\x01\xA8V[a\x01\xC4a\x05\xEEV[a\x01\xEDa\x01\xE86`\x04a\x17\xABV[a\x06\xAFV[\0[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xA8V[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x01\xC4a\x07\xFEV[a\x01\xEDa\x02k6`\x04a\x17\xABV[a\x08\x8FV[a\x01\xEDa\x02~6`\x04a\x18JV[a\t\xF0V[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x01\xC4a\nGV[a\x01\xC4a\x02\xC06`\x04a\x18\xF7V[a\x0B\x01V[a\x01\xC4`\x02\x81V[a\x01\xEDa\x02\xDB6`\x04a\x17\xABV[a\x0B\xECV[a\x01\xEDa\x02\xEE6`\x04a\x17\xABV[a\x0C\xBDV[a\x01\xC4a\x03\x016`\x04a\x17\xABV[a\r\x80V[a\x01\xC4`\n\x81V[a\x02\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x01\xEDa\x0E\x8FV[a\x01\xC4a\x0FNV[a\x01\xC4a\x0FhV[a\x01\xC4a\x0F\xBFV[a\x01\xEDa\x03c6`\x04a\x18JV[a\x10\xF4V[a\x01\xC4a\x11FV[a\x03xa\x11`V[`@\x80Q\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R`\xA0\x82\x01R`\xC0\x01a\x01\xA8V[a\x01\xC4a\x03\xB36`\x04a\x19\x14V[a\x12\x08V[`@Qc5\xEAju`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R``\x91`\0\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c5\xEAju\x90`$\x01a\x01\x80`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04EW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04i\x91\x90a\x19\xC9V[`@\x80Q`\x02\x80\x82R``\x82\x01\x83R\x92\x93P\x91\x90` \x83\x01\x90\x806\x837\x01\x90PP\x91P\x80`\xE0\x01Q\x82`\0\x81Q\x81\x10a\x04\xA4Wa\x04\xA4a\x1A\xBCV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPP\x80a\x01 \x01Q\x82`\x01\x81Q\x81\x10a\x04\xDDWa\x04\xDDa\x1A\xBCV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPPP\x90V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x05TW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Q\x80\x91\x03\x90\xFD[`@Qcp\xA0\x821`\xE0\x1B\x81R3`\x04\x82\x01Ra\x05\xE6\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xBCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xE0\x91\x90a\x1A\xF5V[\x83a\x12\x08V[\x90P[\x91\x90PV[`\0\x80a\x05\xF9a\x11`V[PPP\x92PPPa\x06\x08a\x0F\xBFV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06fW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06\x8A\x91\x90a\x1B\x0EV[a\x06\x95\x90`\na\x1C&V[a\x06\x9F\x90\x83a\x1C5V[a\x06\xA9\x91\x90a\x1CLV[\x91PP\x90V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x06\xF7W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\x07K`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x12\xEFV[`@Qc\xE8\xED\xA9\xDF`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R`\0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xE8\xED\xA9\xDF\x90`\x84\x01[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x07\xE3W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x07\xF7W=`\0\x80>=`\0\xFD[PPPPPV[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90cp\xA0\x821\x90`$\x01[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08fW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x8A\x91\x90a\x1A\xF5V[\x90P\x90V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x08\xD7W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\t+`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x12\xEFV[`@QcW:\xDE\x81`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cW:\xDE\x81\x90`\x84\x01[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\t\xC8W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xEC\x91\x90a\x1A\xF5V[PPV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\n8W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\nB\x82\x82a\x13\x7FV[PPPV[`@Qc\xC4K\x11\xF7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`\0\x91\x82\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xC4K\x11\xF7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xD2W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xF6\x91\x90a\x1CnV[Qa\xFF\xFF\x16\x92\x91PPV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0BKW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xB6\x91\x90a\x1A\xF5V[\x90Pa\x05\xE6`\x01`\x01`\xA0\x1B\x03\x84\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x13\xF5V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0C4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Qc\xA4\x15\xBC\xAD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R`\0`d\x83\x01R0`\x84\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA4\x15\xBC\xAD\x90`\xA4\x01a\x07\xC9V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\r\x05W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`@Qc\x1AL\xA3{`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90ci2\x8D\xEC\x90`d\x01a\t\xA9V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\r\xCAW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[`\0a\r\xD4a\x11`V[P\x94PPPPP`\0[\x83\x81\x10\x80\x15a\r\xF4WP`\0a\r\xF2a\x0FNV[\x11[\x15a\x0EDWa\x0E'`\n\x83a\x0E\x07a\x05\xEEV[a\x0E\x13\x90a'\x10a\x1C5V[a\x0E\x1D\x91\x90a\x1CLV[a\x02\xEE\x91\x90a\x1C\x8AV[a\x0E2a\x02ka\x07\xFEV[\x80a\x0E<\x81a\x1C\x9DV[\x91PPa\r\xDEV[Pa\x0EMa\x0FNV[`\0\x03a\x0E_Wa\x0E_`\0\x19a\x0C\xBDV[a\x0E\x88\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x0B\x01V[\x93\x92PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c1\x11\xE7\xB3a\x0E\xC6a\x03\xB8V[`\0\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0F\x08\x93\x92\x91\x90a\x1C\xB6V[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x0F'W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0FK\x91\x90a\x1A\xF5V[PV[`\0\x80a\x0FYa\x11`V[PPPP\x91PPa\x06\x08a\x0F\xBFV[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x8BY\x9F&a\x0F\xA1a\x03\xB8V[0`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x08I\x92\x91\x90a\x1C\xE9V[`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\xFEe\xAC\xFE`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x1FW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10C\x91\x90a\x1D\x13V[`\x01`\x01`\xA0\x1B\x03\x16c\xFC\xA5\x13\xA8`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\x80W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\xA4\x91\x90a\x1D\x13V[`@Qc\xB3Yo\x07`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R\x91\x90\x91\x16\x90c\xB3Yo\x07\x90`$\x01a\x08IV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x11<W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[a\nB\x82\x82a\x14TV[`\0\x80a\x11Qa\x11`V[PPPPP\x90Pa\x06\x08a\x0F\xBFV[`@Qc/\xE4\xA1_`\xE2\x1B\x81R0`\x04\x82\x01R`\0\x90\x81\x90\x81\x90\x81\x90\x81\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xBF\x92\x85|\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11\xD1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\xF5\x91\x90a\x1D0V[\x94\x9B\x93\x9AP\x91\x98P\x96P\x94P\x90\x92P\x90PV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x12RW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05K\x90a\x1A\xD2V[\x82\x15a\x12\x8DWa\x12\x8D`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1630\x86a\x14bV[`\0a\x12\x97a\x07\xFEV[\x11\x15a\x12\xA8Wa\x12\xA8a\x01\xE8a\x07\xFEV[`\0[\x82\x81\x10\x15a\x12\xDDWa\x12\xCA`\na\x12\xC0a\x05\xEEV[a\x02\xDB\x91\x90a\x1C\x8AV[a\x12\xD5a\x01\xE8a\x07\xFEV[`\x01\x01a\x12\xABV[Pa\x12\xE6a\x05\xEEV[\x90P[\x92\x91PPV[`@Qcn\xB1v\x9F`\xE1\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`\0\x91\x90\x85\x16\x90c\xDDb\xED>\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13?W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13c\x91\x90a\x1A\xF5V[\x90Pa\x13y\x84\x84a\x13t\x85\x85a\x1DzV[a\x14\x9BV[PPPPV[```\0\x80\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x13\x9C\x91\x90a\x1D\x8DV[`\0`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80`\0\x81\x14a\x13\xD7W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x13\xDCV[``\x91P[P\x91P\x91Pa\x13\xEC\x85\x83\x83a\x15+V[\x95\x94PPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`D\x82\x01\x83\x90Ra\nB\x91\x85\x91\x82\x16\x90c\xA9\x05\x9C\xBB\x90`d\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x91P`\xE0\x1B` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x83\x81\x83\x16\x17\x83RPPPPa\x15\x87V[``a\x12\xE6\x83\x83`\0a\x15\xEAV[`@Q`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`$\x83\x01R\x83\x81\x16`D\x83\x01R`d\x82\x01\x83\x90Ra\x13y\x91\x86\x91\x82\x16\x90c#\xB8r\xDD\x90`\x84\x01a\x14\"V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90Ra\x14\xEC\x84\x82a\x16\x87V[a\x13yW`@Q`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`$\x83\x01R`\0`D\x83\x01Ra\x15!\x91\x86\x91\x82\x16\x90c\t^\xA7\xB3\x90`d\x01a\x14\"V[a\x13y\x84\x82a\x15\x87V[``\x82a\x15@Wa\x15;\x82a\x17*V[a\x0E\x88V[\x81Q\x15\x80\x15a\x15WWP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x15\x80W`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x05KV[P\x92\x91PPV[`\0a\x15\x9C`\x01`\x01`\xA0\x1B\x03\x84\x16\x83a\x14TV[\x90P\x80Q`\0\x14\x15\x80\x15a\x15\xC1WP\x80\x80` \x01\x90Q\x81\x01\x90a\x15\xBF\x91\x90a\x1D\xBCV[\x15[\x15a\nBW`@QcRt\xAF\xE7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04\x82\x01R`$\x01a\x05KV[``\x81G\x10\x15a\x16\x0FW`@Qc\xCDx`Y`\xE0\x1B\x81R0`\x04\x82\x01R`$\x01a\x05KV[`\0\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x84\x86`@Qa\x16+\x91\x90a\x1D\x8DV[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x16hW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x16mV[``\x91P[P\x91P\x91Pa\x16}\x86\x83\x83a\x15+V[\x96\x95PPPPPPV[`\0\x80`\0\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x16\xA4\x91\x90a\x1D\x8DV[`\0`@Q\x80\x83\x03\x81`\0\x86Z\xF1\x91PP=\x80`\0\x81\x14a\x16\xE1W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x16\xE6V[``\x91P[P\x91P\x91P\x81\x80\x15a\x17\x10WP\x80Q\x15\x80a\x17\x10WP\x80\x80` \x01\x90Q\x81\x01\x90a\x17\x10\x91\x90a\x1D\xBCV[\x80\x15a\x13\xECWPPPPP`\x01`\x01`\xA0\x1B\x03\x16;\x15\x15\x90V[\x80Q\x15a\x17:W\x80Q\x80\x82` \x01\xFD[`@Qc\n\x12\xF5!`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\0\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01`\0[\x82\x81\x10\x15a\x17\x8EW\x81Q`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x17gV[P\x93\x94\x93PPPPV[` \x81R`\0a\x12\xE6` \x83\x01\x84a\x17SV[`\0` \x82\x84\x03\x12\x15a\x17\xBDW`\0\x80\xFD[P5\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0FKW`\0\x80\xFD[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`@Qa\x01\x80\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18\x13Wa\x18\x13a\x17\xD9V[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x18BWa\x18Ba\x17\xD9V[`@R\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x18]W`\0\x80\xFD[\x825a\x18h\x81a\x17\xC4V[\x91P` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\x84W`\0\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\x18\x95W`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x18\xAFWa\x18\xAFa\x17\xD9V[a\x18\xC2`\x1F\x82\x01`\x1F\x19\x16` \x01a\x18\x19V[\x81\x81R\x86` \x83\x85\x01\x01\x11\x15a\x18\xD7W`\0\x80\xFD[\x81` \x84\x01` \x83\x017`\0` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15a\x19\tW`\0\x80\xFD[\x815a\x0E\x88\x81a\x17\xC4V[`\0\x80`@\x83\x85\x03\x12\x15a\x19'W`\0\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[`\0` \x82\x84\x03\x12\x15a\x19HW`\0\x80\xFD[`@Q` \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a\x19kWa\x19ka\x17\xD9V[`@R\x91Q\x82RP\x91\x90PV[\x80Qo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xE9W`\0\x80\xFD[\x80Qd\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xE9W`\0\x80\xFD[\x80Qa\x05\xE9\x81a\x17\xC4V[\x80Q`\xFF\x81\x16\x81\x14a\x05\xE9W`\0\x80\xFD[`\0a\x01\x80\x82\x84\x03\x12\x80\x15a\x19\xDDW`\0\x80\xFD[Pa\x19\xE6a\x17\xEFV[a\x19\xF0\x84\x84a\x196V[\x81Ra\x19\xFE` \x84\x01a\x19xV[` \x82\x01Ra\x1A\x0F`@\x84\x01a\x19xV[`@\x82\x01Ra\x1A ``\x84\x01a\x19xV[``\x82\x01Ra\x1A1`\x80\x84\x01a\x19xV[`\x80\x82\x01Ra\x1AB`\xA0\x84\x01a\x19xV[`\xA0\x82\x01Ra\x1AS`\xC0\x84\x01a\x19\x98V[`\xC0\x82\x01Ra\x1Ad`\xE0\x84\x01a\x19\xADV[`\xE0\x82\x01Ra\x1Ava\x01\0\x84\x01a\x19\xADV[a\x01\0\x82\x01Ra\x1A\x89a\x01 \x84\x01a\x19\xADV[a\x01 \x82\x01Ra\x1A\x9Ca\x01@\x84\x01a\x19\xADV[a\x01@\x82\x01Ra\x1A\xAFa\x01`\x84\x01a\x19\xB8V[a\x01`\x82\x01R\x93\x92PPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[` \x80\x82R`\t\x90\x82\x01Rh7\xB76<\xA7\xBB\xB72\xB9`\xB9\x1B`@\x82\x01R``\x01\x90V[`\0` \x82\x84\x03\x12\x15a\x1B\x07W`\0\x80\xFD[PQ\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x1B W`\0\x80\xFD[a\x12\xE6\x82a\x19\xB8V[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[`\x01\x81[`\x01\x84\x11\x15a\x1BzW\x80\x85\x04\x81\x11\x15a\x1B^Wa\x1B^a\x1B)V[`\x01\x84\x16\x15a\x1BlW\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a\x1BCV[\x93P\x93\x91PPV[`\0\x82a\x1B\x91WP`\x01a\x12\xE9V[\x81a\x1B\x9EWP`\0a\x12\xE9V[\x81`\x01\x81\x14a\x1B\xB4W`\x02\x81\x14a\x1B\xBEWa\x1B\xDAV[`\x01\x91PPa\x12\xE9V[`\xFF\x84\x11\x15a\x1B\xCFWa\x1B\xCFa\x1B)V[PP`\x01\x82\x1Ba\x12\xE9V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x1B\xFDWP\x81\x81\na\x12\xE9V[a\x1C\n`\0\x19\x84\x84a\x1B?V[\x80`\0\x19\x04\x82\x11\x15a\x1C\x1EWa\x1C\x1Ea\x1B)V[\x02\x93\x92PPPV[`\0a\x12\xE6`\xFF\x84\x16\x83a\x1B\x82V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x12\xE9Wa\x12\xE9a\x1B)V[`\0\x82a\x1CiWcNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[P\x04\x90V[`\0` \x82\x84\x03\x12\x15a\x1C\x80W`\0\x80\xFD[a\x12\xE6\x83\x83a\x196V[\x81\x81\x03\x81\x81\x11\x15a\x12\xE9Wa\x12\xE9a\x1B)V[`\0`\x01\x82\x01a\x1C\xAFWa\x1C\xAFa\x1B)V[P`\x01\x01\x90V[``\x81R`\0a\x1C\xC9``\x83\x01\x86a\x17SV[` \x83\x01\x94\x90\x94RP`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`@\x90\x91\x01R\x91\x90PV[`@\x81R`\0a\x1C\xFC`@\x83\x01\x85a\x17SV[\x90P`\x01\x80`\xA0\x1B\x03\x83\x16` \x83\x01R\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15a\x1D%W`\0\x80\xFD[\x81Qa\x0E\x88\x81a\x17\xC4V[`\0\x80`\0\x80`\0\x80`\xC0\x87\x89\x03\x12\x15a\x1DIW`\0\x80\xFD[PP\x84Q` \x86\x01Q`@\x87\x01Q``\x88\x01Q`\x80\x89\x01Q`\xA0\x90\x99\x01Q\x93\x9A\x92\x99P\x90\x97\x90\x96P\x94P\x90\x92P\x90PV[\x80\x82\x01\x80\x82\x11\x15a\x12\xE9Wa\x12\xE9a\x1B)V[`\0\x82Q`\0[\x81\x81\x10\x15a\x1D\xAEW` \x81\x86\x01\x81\x01Q\x85\x83\x01R\x01a\x1D\x94V[P`\0\x92\x01\x91\x82RP\x91\x90PV[`\0` \x82\x84\x03\x12\x15a\x1D\xCEW`\0\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x0E\x88W`\0\x80\xFD\xFE\xA2dipfsX\"\x12 P\x9BT\xF2\xBC\xFCio\xFB\xD9\x05\xAD\xB3\xC7\x01\xEDK\xA0\x1F\xE1\x0C\x9AC\"J\xFB\nz\x9B\xCBT\x0EdsolcC\0\x08\x1A\x003",
    );
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `AddressInsufficientBalance(address)` and selector `0xcd786059`.
```solidity
error AddressInsufficientBalance(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AddressInsufficientBalance {
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressInsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: AddressInsufficientBalance) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AddressInsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressInsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressInsufficientBalance(address)";
            const SELECTOR: [u8; 4] = [205u8, 120u8, 96u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `FailedInnerCall()` and selector `0x1425ea42`.
```solidity
error FailedInnerCall();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct FailedInnerCall {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedInnerCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedInnerCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedInnerCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedInnerCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedInnerCall()";
            const SELECTOR: [u8; 4] = [20u8, 37u8, 234u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address owner, address asset, address lendingPool, address incentives);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub owner: alloy::sol_types::private::Address,
        pub asset: alloy::sol_types::private::Address,
        pub lendingPool: alloy::sol_types::private::Address,
        pub incentives: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.owner, value.asset, value.lendingPool, value.incentives)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        asset: tuple.1,
                        lendingPool: tuple.2,
                        incentives: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lendingPool,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.incentives,
                    ),
                )
            }
        }
    };
    /**Function with signature `ASSET()` and selector `0x4800d97f`.
```solidity
function ASSET() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ASSETCall {}
    ///Container type for the return parameters of the [`ASSET()`](ASSETCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ASSETReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ASSETCall> for UnderlyingRustTuple<'_> {
                fn from(value: ASSETCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ASSETCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ASSETReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ASSETReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ASSETReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ASSETCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ASSETReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ASSET()";
            const SELECTOR: [u8; 4] = [72u8, 0u8, 217u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INCENTIVES()` and selector `0x131e190a`.
```solidity
function INCENTIVES() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct INCENTIVESCall {}
    ///Container type for the return parameters of the [`INCENTIVES()`](INCENTIVESCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct INCENTIVESReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INCENTIVESCall> for UnderlyingRustTuple<'_> {
                fn from(value: INCENTIVESCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INCENTIVESCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INCENTIVESReturn> for UnderlyingRustTuple<'_> {
                fn from(value: INCENTIVESReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for INCENTIVESReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INCENTIVESCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INCENTIVESReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INCENTIVES()";
            const SELECTOR: [u8; 4] = [19u8, 30u8, 25u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LENDING_POOL()` and selector `0xb4dcfc77`.
```solidity
function LENDING_POOL() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct LENDING_POOLCall {}
    ///Container type for the return parameters of the [`LENDING_POOL()`](LENDING_POOLCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct LENDING_POOLReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LENDING_POOLCall> for UnderlyingRustTuple<'_> {
                fn from(value: LENDING_POOLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LENDING_POOLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LENDING_POOLReturn> for UnderlyingRustTuple<'_> {
                fn from(value: LENDING_POOLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LENDING_POOLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LENDING_POOLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LENDING_POOLReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LENDING_POOL()";
            const SELECTOR: [u8; 4] = [180u8, 220u8, 252u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OWNER()` and selector `0x117803e3`.
```solidity
function OWNER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OWNERCall {}
    ///Container type for the return parameters of the [`OWNER()`](OWNERCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OWNERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OWNERCall> for UnderlyingRustTuple<'_> {
                fn from(value: OWNERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OWNERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OWNERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OWNERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OWNERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OWNERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OWNERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OWNER()";
            const SELECTOR: [u8; 4] = [17u8, 120u8, 3u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SAFE_BUFFER()` and selector `0x8a0ccf6c`.
```solidity
function SAFE_BUFFER() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SAFE_BUFFERCall {}
    ///Container type for the return parameters of the [`SAFE_BUFFER()`](SAFE_BUFFERCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SAFE_BUFFERReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SAFE_BUFFERCall> for UnderlyingRustTuple<'_> {
                fn from(value: SAFE_BUFFERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SAFE_BUFFERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SAFE_BUFFERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SAFE_BUFFERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SAFE_BUFFERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SAFE_BUFFERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SAFE_BUFFERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SAFE_BUFFER()";
            const SELECTOR: [u8; 4] = [138u8, 12u8, 207u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `USE_VARIABLE_DEBT()` and selector `0x5ddfbc5b`.
```solidity
function USE_VARIABLE_DEBT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct USE_VARIABLE_DEBTCall {}
    ///Container type for the return parameters of the [`USE_VARIABLE_DEBT()`](USE_VARIABLE_DEBTCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct USE_VARIABLE_DEBTReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USE_VARIABLE_DEBTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: USE_VARIABLE_DEBTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for USE_VARIABLE_DEBTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USE_VARIABLE_DEBTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: USE_VARIABLE_DEBTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for USE_VARIABLE_DEBTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for USE_VARIABLE_DEBTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = USE_VARIABLE_DEBTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "USE_VARIABLE_DEBT()";
            const SELECTOR: [u8; 4] = [93u8, 223u8, 188u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_borrow(uint256)` and selector `0x63e54bb1`.
```solidity
function _borrow(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _borrowCall {
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`_borrow(uint256)`](_borrowCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _borrowReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_borrowCall> for UnderlyingRustTuple<'_> {
                fn from(value: _borrowCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _borrowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_borrowReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _borrowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _borrowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _borrowCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _borrowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_borrow(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 229u8, 75u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_redeemSupply(uint256)` and selector `0x76307313`.
```solidity
function _redeemSupply(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _redeemSupplyCall {
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`_redeemSupply(uint256)`](_redeemSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _redeemSupplyReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_redeemSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: _redeemSupplyCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _redeemSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_redeemSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _redeemSupplyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _redeemSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _redeemSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _redeemSupplyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_redeemSupply(uint256)";
            const SELECTOR: [u8; 4] = [118u8, 48u8, 115u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_repayBorrow(uint256)` and selector `0x22110c9d`.
```solidity
function _repayBorrow(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _repayBorrowCall {
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`_repayBorrow(uint256)`](_repayBorrowCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _repayBorrowReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_repayBorrowCall> for UnderlyingRustTuple<'_> {
                fn from(value: _repayBorrowCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _repayBorrowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_repayBorrowReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _repayBorrowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _repayBorrowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _repayBorrowCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _repayBorrowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_repayBorrow(uint256)";
            const SELECTOR: [u8; 4] = [34u8, 17u8, 12u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_supply(uint256)` and selector `0x09382758`.
```solidity
function _supply(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _supplyCall {
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`_supply(uint256)`](_supplyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _supplyReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_supplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: _supplyCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _supplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_supplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _supplyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _supplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _supplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _supplyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_supply(uint256)";
            const SELECTOR: [u8; 4] = [9u8, 56u8, 39u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_withdrawToOwner(address)` and selector `0x5886e7c1`.
```solidity
function _withdrawToOwner(address asset) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _withdrawToOwnerCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`_withdrawToOwner(address)`](_withdrawToOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _withdrawToOwnerReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_withdrawToOwnerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: _withdrawToOwnerCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _withdrawToOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_withdrawToOwnerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: _withdrawToOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _withdrawToOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _withdrawToOwnerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _withdrawToOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_withdrawToOwner(address)";
            const SELECTOR: [u8; 4] = [88u8, 134u8, 231u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimRewardsToOwner()` and selector `0xbd345f14`.
```solidity
function claimRewardsToOwner() external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct claimRewardsToOwnerCall {}
    ///Container type for the return parameters of the [`claimRewardsToOwner()`](claimRewardsToOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct claimRewardsToOwnerReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimRewardsToOwnerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimRewardsToOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimRewardsToOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimRewardsToOwnerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimRewardsToOwnerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimRewardsToOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimRewardsToOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimRewardsToOwnerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimRewardsToOwner()";
            const SELECTOR: [u8; 4] = [189u8, 52u8, 95u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emergencyFunctionCall(address,bytes)` and selector `0xe78d73ad`.
```solidity
function emergencyFunctionCall(address target, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionCallCall {
        pub target: alloy::sol_types::private::Address,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`emergencyFunctionCall(address,bytes)`](emergencyFunctionCallCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionCallReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionCallCall) -> Self {
                    (value.target, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        target: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emergencyFunctionCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emergencyFunctionCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emergencyFunctionCall(address,bytes)";
            const SELECTOR: [u8; 4] = [231u8, 141u8, 115u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emergencyFunctionDelegateCall(address,bytes)` and selector `0x2ab0aabb`.
```solidity
function emergencyFunctionDelegateCall(address target, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionDelegateCallCall {
        pub target: alloy::sol_types::private::Address,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`emergencyFunctionDelegateCall(address,bytes)`](emergencyFunctionDelegateCallCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionDelegateCallReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionDelegateCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionDelegateCallCall) -> Self {
                    (value.target, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionDelegateCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        target: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionDelegateCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionDelegateCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionDelegateCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emergencyFunctionDelegateCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emergencyFunctionDelegateCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emergencyFunctionDelegateCall(address,bytes)";
            const SELECTOR: [u8; 4] = [42u8, 176u8, 170u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `enterPosition(uint256,uint256)` and selector `0xfbdf7b45`.
```solidity
function enterPosition(uint256 principal, uint256 iterations) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct enterPositionCall {
        pub principal: alloy::sol_types::private::U256,
        pub iterations: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`enterPosition(uint256,uint256)`](enterPositionCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct enterPositionReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enterPositionCall> for UnderlyingRustTuple<'_> {
                fn from(value: enterPositionCall) -> Self {
                    (value.principal, value.iterations)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enterPositionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        principal: tuple.0,
                        iterations: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enterPositionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: enterPositionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enterPositionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enterPositionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enterPositionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enterPosition(uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 223u8, 123u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.principal),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iterations),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `enterPositionFully(uint256)` and selector `0x0854dc45`.
```solidity
function enterPositionFully(uint256 iterations) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct enterPositionFullyCall {
        pub iterations: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`enterPositionFully(uint256)`](enterPositionFullyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct enterPositionFullyReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enterPositionFullyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: enterPositionFullyCall) -> Self {
                    (value.iterations,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enterPositionFullyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { iterations: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enterPositionFullyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: enterPositionFullyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enterPositionFullyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enterPositionFullyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enterPositionFullyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enterPositionFully(uint256)";
            const SELECTOR: [u8; 4] = [8u8, 84u8, 220u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iterations),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exitPosition(uint256)` and selector `0x78dc9059`.
```solidity
function exitPosition(uint256 iterations) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exitPositionCall {
        pub iterations: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`exitPosition(uint256)`](exitPositionCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exitPositionReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exitPositionCall> for UnderlyingRustTuple<'_> {
                fn from(value: exitPositionCall) -> Self {
                    (value.iterations,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exitPositionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { iterations: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exitPositionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: exitPositionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exitPositionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exitPositionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exitPositionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exitPosition(uint256)";
            const SELECTOR: [u8; 4] = [120u8, 220u8, 144u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iterations),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAssetBalance()` and selector `0x183b3159`.
```solidity
function getAssetBalance() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetBalanceCall {}
    ///Container type for the return parameters of the [`getAssetBalance()`](getAssetBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetBalanceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetBalanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAssetBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAssetBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAssetBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAssetBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAssetBalance()";
            const SELECTOR: [u8; 4] = [24u8, 59u8, 49u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAssetPrice()` and selector `0xe54f0880`.
```solidity
function getAssetPrice() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetPriceCall {}
    ///Container type for the return parameters of the [`getAssetPrice()`](getAssetPriceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetPriceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetPriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetPriceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetPriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetPriceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetPriceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetPriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAssetPriceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAssetPriceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAssetPrice()";
            const SELECTOR: [u8; 4] = [229u8, 79u8, 8u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBorrowBalance()` and selector `0xca206591`.
```solidity
function getBorrowBalance() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getBorrowBalanceCall {}
    ///Container type for the return parameters of the [`getBorrowBalance()`](getBorrowBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getBorrowBalanceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBorrowBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBorrowBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBorrowBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBorrowBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBorrowBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBorrowBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBorrowBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBorrowBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBorrowBalance()";
            const SELECTOR: [u8; 4] = [202u8, 32u8, 101u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLTV()` and selector `0x4ed2b8ac`.
```solidity
function getLTV() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLTVCall {}
    ///Container type for the return parameters of the [`getLTV()`](getLTVCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLTVReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLTVCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLTVCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLTVCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLTVReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLTVReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLTVReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLTVCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLTVReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLTV()";
            const SELECTOR: [u8; 4] = [78u8, 210u8, 184u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLiquidity()` and selector `0x0910a510`.
```solidity
function getLiquidity() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLiquidityCall {}
    ///Container type for the return parameters of the [`getLiquidity()`](getLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLiquidityReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLiquidityCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLiquidityCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLiquidityReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLiquidityReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLiquidityCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLiquidityReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLiquidity()";
            const SELECTOR: [u8; 4] = [9u8, 16u8, 165u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPendingRewards()` and selector `0xd9621f9e`.
```solidity
function getPendingRewards() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getPendingRewardsCall {}
    ///Container type for the return parameters of the [`getPendingRewards()`](getPendingRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getPendingRewardsReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingRewardsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingRewardsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingRewardsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPendingRewardsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPendingRewardsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPendingRewards()";
            const SELECTOR: [u8; 4] = [217u8, 98u8, 31u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPositionData()` and selector `0xe8f37963`.
```solidity
function getPositionData() external view returns (uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getPositionDataCall {}
    ///Container type for the return parameters of the [`getPositionData()`](getPositionDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getPositionDataReturn {
        pub totalCollateralETH: alloy::sol_types::private::U256,
        pub totalDebtETH: alloy::sol_types::private::U256,
        pub availableBorrowsETH: alloy::sol_types::private::U256,
        pub currentLiquidationThreshold: alloy::sol_types::private::U256,
        pub ltv: alloy::sol_types::private::U256,
        pub healthFactor: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPositionDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPositionDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPositionDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPositionDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPositionDataReturn) -> Self {
                    (
                        value.totalCollateralETH,
                        value.totalDebtETH,
                        value.availableBorrowsETH,
                        value.currentLiquidationThreshold,
                        value.ltv,
                        value.healthFactor,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPositionDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        totalCollateralETH: tuple.0,
                        totalDebtETH: tuple.1,
                        availableBorrowsETH: tuple.2,
                        currentLiquidationThreshold: tuple.3,
                        ltv: tuple.4,
                        healthFactor: tuple.5,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPositionDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPositionDataReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPositionData()";
            const SELECTOR: [u8; 4] = [232u8, 243u8, 121u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getSupplyAndBorrowAssets()` and selector `0x020d5170`.
```solidity
function getSupplyAndBorrowAssets() external view returns (address[] memory assets);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getSupplyAndBorrowAssetsCall {}
    ///Container type for the return parameters of the [`getSupplyAndBorrowAssets()`](getSupplyAndBorrowAssetsCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getSupplyAndBorrowAssetsReturn {
        pub assets: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupplyAndBorrowAssetsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupplyAndBorrowAssetsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupplyAndBorrowAssetsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupplyAndBorrowAssetsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupplyAndBorrowAssetsReturn) -> Self {
                    (value.assets,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupplyAndBorrowAssetsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assets: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSupplyAndBorrowAssetsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSupplyAndBorrowAssetsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSupplyAndBorrowAssets()";
            const SELECTOR: [u8; 4] = [2u8, 13u8, 81u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getSupplyBalance()` and selector `0xe8c944e6`.
```solidity
function getSupplyBalance() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getSupplyBalanceCall {}
    ///Container type for the return parameters of the [`getSupplyBalance()`](getSupplyBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getSupplyBalanceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupplyBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupplyBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupplyBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupplyBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupplyBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupplyBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSupplyBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSupplyBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSupplyBalance()";
            const SELECTOR: [u8; 4] = [232u8, 201u8, 68u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`AaveLooper`](self) function calls.
    pub enum AaveLooperCalls {
        ASSET(ASSETCall),
        INCENTIVES(INCENTIVESCall),
        LENDING_POOL(LENDING_POOLCall),
        OWNER(OWNERCall),
        SAFE_BUFFER(SAFE_BUFFERCall),
        USE_VARIABLE_DEBT(USE_VARIABLE_DEBTCall),
        _borrow(_borrowCall),
        _redeemSupply(_redeemSupplyCall),
        _repayBorrow(_repayBorrowCall),
        _supply(_supplyCall),
        _withdrawToOwner(_withdrawToOwnerCall),
        claimRewardsToOwner(claimRewardsToOwnerCall),
        emergencyFunctionCall(emergencyFunctionCallCall),
        emergencyFunctionDelegateCall(emergencyFunctionDelegateCallCall),
        enterPosition(enterPositionCall),
        enterPositionFully(enterPositionFullyCall),
        exitPosition(exitPositionCall),
        getAssetBalance(getAssetBalanceCall),
        getAssetPrice(getAssetPriceCall),
        getBorrowBalance(getBorrowBalanceCall),
        getLTV(getLTVCall),
        getLiquidity(getLiquidityCall),
        getPendingRewards(getPendingRewardsCall),
        getPositionData(getPositionDataCall),
        getSupplyAndBorrowAssets(getSupplyAndBorrowAssetsCall),
        getSupplyBalance(getSupplyBalanceCall),
    }
    #[automatically_derived]
    impl AaveLooperCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 13u8, 81u8, 112u8],
            [8u8, 84u8, 220u8, 69u8],
            [9u8, 16u8, 165u8, 16u8],
            [9u8, 56u8, 39u8, 88u8],
            [17u8, 120u8, 3u8, 227u8],
            [19u8, 30u8, 25u8, 10u8],
            [24u8, 59u8, 49u8, 89u8],
            [34u8, 17u8, 12u8, 157u8],
            [42u8, 176u8, 170u8, 187u8],
            [72u8, 0u8, 217u8, 127u8],
            [78u8, 210u8, 184u8, 172u8],
            [88u8, 134u8, 231u8, 193u8],
            [93u8, 223u8, 188u8, 91u8],
            [99u8, 229u8, 75u8, 177u8],
            [118u8, 48u8, 115u8, 19u8],
            [120u8, 220u8, 144u8, 89u8],
            [138u8, 12u8, 207u8, 108u8],
            [180u8, 220u8, 252u8, 119u8],
            [189u8, 52u8, 95u8, 20u8],
            [202u8, 32u8, 101u8, 145u8],
            [217u8, 98u8, 31u8, 158u8],
            [229u8, 79u8, 8u8, 128u8],
            [231u8, 141u8, 115u8, 173u8],
            [232u8, 201u8, 68u8, 230u8],
            [232u8, 243u8, 121u8, 99u8],
            [251u8, 223u8, 123u8, 69u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for AaveLooperCalls {
        const NAME: &'static str = "AaveLooperCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 26usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ASSET(_) => <ASSETCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::INCENTIVES(_) => {
                    <INCENTIVESCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LENDING_POOL(_) => {
                    <LENDING_POOLCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::OWNER(_) => <OWNERCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::SAFE_BUFFER(_) => {
                    <SAFE_BUFFERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::USE_VARIABLE_DEBT(_) => {
                    <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_borrow(_) => <_borrowCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::_redeemSupply(_) => {
                    <_redeemSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_repayBorrow(_) => {
                    <_repayBorrowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_supply(_) => <_supplyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::_withdrawToOwner(_) => {
                    <_withdrawToOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimRewardsToOwner(_) => {
                    <claimRewardsToOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emergencyFunctionCall(_) => {
                    <emergencyFunctionCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emergencyFunctionDelegateCall(_) => {
                    <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enterPosition(_) => {
                    <enterPositionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enterPositionFully(_) => {
                    <enterPositionFullyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exitPosition(_) => {
                    <exitPositionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAssetBalance(_) => {
                    <getAssetBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAssetPrice(_) => {
                    <getAssetPriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBorrowBalance(_) => {
                    <getBorrowBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLTV(_) => <getLTVCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLiquidity(_) => {
                    <getLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPendingRewards(_) => {
                    <getPendingRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPositionData(_) => {
                    <getPositionDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSupplyAndBorrowAssets(_) => {
                    <getSupplyAndBorrowAssetsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSupplyBalance(_) => {
                    <getSupplyBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<AaveLooperCalls>] = &[
                {
                    fn getSupplyAndBorrowAssets(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getSupplyAndBorrowAssetsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getSupplyAndBorrowAssets)
                    }
                    getSupplyAndBorrowAssets
                },
                {
                    fn enterPositionFully(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <enterPositionFullyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::enterPositionFully)
                    }
                    enterPositionFully
                },
                {
                    fn getLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getLiquidity)
                    }
                    getLiquidity
                },
                {
                    fn _supply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_supplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_supply)
                    }
                    _supply
                },
                {
                    fn OWNER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <OWNERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::OWNER)
                    }
                    OWNER
                },
                {
                    fn INCENTIVES(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <INCENTIVESCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::INCENTIVES)
                    }
                    INCENTIVES
                },
                {
                    fn getAssetBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getAssetBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getAssetBalance)
                    }
                    getAssetBalance
                },
                {
                    fn _repayBorrow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_repayBorrowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_repayBorrow)
                    }
                    _repayBorrow
                },
                {
                    fn emergencyFunctionDelegateCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::emergencyFunctionDelegateCall)
                    }
                    emergencyFunctionDelegateCall
                },
                {
                    fn ASSET(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <ASSETCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::ASSET)
                    }
                    ASSET
                },
                {
                    fn getLTV(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getLTVCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getLTV)
                    }
                    getLTV
                },
                {
                    fn _withdrawToOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_withdrawToOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_withdrawToOwner)
                    }
                    _withdrawToOwner
                },
                {
                    fn USE_VARIABLE_DEBT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::USE_VARIABLE_DEBT)
                    }
                    USE_VARIABLE_DEBT
                },
                {
                    fn _borrow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_borrowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_borrow)
                    }
                    _borrow
                },
                {
                    fn _redeemSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_redeemSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_redeemSupply)
                    }
                    _redeemSupply
                },
                {
                    fn exitPosition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <exitPositionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::exitPosition)
                    }
                    exitPosition
                },
                {
                    fn SAFE_BUFFER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <SAFE_BUFFERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::SAFE_BUFFER)
                    }
                    SAFE_BUFFER
                },
                {
                    fn LENDING_POOL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <LENDING_POOLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::LENDING_POOL)
                    }
                    LENDING_POOL
                },
                {
                    fn claimRewardsToOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <claimRewardsToOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::claimRewardsToOwner)
                    }
                    claimRewardsToOwner
                },
                {
                    fn getBorrowBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getBorrowBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getBorrowBalance)
                    }
                    getBorrowBalance
                },
                {
                    fn getPendingRewards(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getPendingRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getPendingRewards)
                    }
                    getPendingRewards
                },
                {
                    fn getAssetPrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getAssetPriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getAssetPrice)
                    }
                    getAssetPrice
                },
                {
                    fn emergencyFunctionCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <emergencyFunctionCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::emergencyFunctionCall)
                    }
                    emergencyFunctionCall
                },
                {
                    fn getSupplyBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getSupplyBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getSupplyBalance)
                    }
                    getSupplyBalance
                },
                {
                    fn getPositionData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getPositionDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getPositionData)
                    }
                    getPositionData
                },
                {
                    fn enterPosition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <enterPositionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::enterPosition)
                    }
                    enterPosition
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ASSET(inner) => {
                    <ASSETCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::INCENTIVES(inner) => {
                    <INCENTIVESCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::LENDING_POOL(inner) => {
                    <LENDING_POOLCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OWNER(inner) => {
                    <OWNERCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SAFE_BUFFER(inner) => {
                    <SAFE_BUFFERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::USE_VARIABLE_DEBT(inner) => {
                    <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_borrow(inner) => {
                    <_borrowCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::_redeemSupply(inner) => {
                    <_redeemSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_repayBorrow(inner) => {
                    <_repayBorrowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_supply(inner) => {
                    <_supplyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::_withdrawToOwner(inner) => {
                    <_withdrawToOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimRewardsToOwner(inner) => {
                    <claimRewardsToOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emergencyFunctionCall(inner) => {
                    <emergencyFunctionCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emergencyFunctionDelegateCall(inner) => {
                    <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enterPosition(inner) => {
                    <enterPositionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enterPositionFully(inner) => {
                    <enterPositionFullyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::exitPosition(inner) => {
                    <exitPositionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAssetBalance(inner) => {
                    <getAssetBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAssetPrice(inner) => {
                    <getAssetPriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBorrowBalance(inner) => {
                    <getBorrowBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLTV(inner) => {
                    <getLTVCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getLiquidity(inner) => {
                    <getLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPendingRewards(inner) => {
                    <getPendingRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPositionData(inner) => {
                    <getPositionDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSupplyAndBorrowAssets(inner) => {
                    <getSupplyAndBorrowAssetsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSupplyBalance(inner) => {
                    <getSupplyBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ASSET(inner) => {
                    <ASSETCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::INCENTIVES(inner) => {
                    <INCENTIVESCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LENDING_POOL(inner) => {
                    <LENDING_POOLCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OWNER(inner) => {
                    <OWNERCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::SAFE_BUFFER(inner) => {
                    <SAFE_BUFFERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::USE_VARIABLE_DEBT(inner) => {
                    <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_borrow(inner) => {
                    <_borrowCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::_redeemSupply(inner) => {
                    <_redeemSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_repayBorrow(inner) => {
                    <_repayBorrowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_supply(inner) => {
                    <_supplyCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::_withdrawToOwner(inner) => {
                    <_withdrawToOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimRewardsToOwner(inner) => {
                    <claimRewardsToOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emergencyFunctionCall(inner) => {
                    <emergencyFunctionCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emergencyFunctionDelegateCall(inner) => {
                    <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enterPosition(inner) => {
                    <enterPositionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enterPositionFully(inner) => {
                    <enterPositionFullyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exitPosition(inner) => {
                    <exitPositionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAssetBalance(inner) => {
                    <getAssetBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAssetPrice(inner) => {
                    <getAssetPriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBorrowBalance(inner) => {
                    <getBorrowBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLTV(inner) => {
                    <getLTVCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getLiquidity(inner) => {
                    <getLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPendingRewards(inner) => {
                    <getPendingRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPositionData(inner) => {
                    <getPositionDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSupplyAndBorrowAssets(inner) => {
                    <getSupplyAndBorrowAssetsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSupplyBalance(inner) => {
                    <getSupplyBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`AaveLooper`](self) custom errors.
    pub enum AaveLooperErrors {
        AddressEmptyCode(AddressEmptyCode),
        AddressInsufficientBalance(AddressInsufficientBalance),
        FailedInnerCall(FailedInnerCall),
        SafeERC20FailedOperation(SafeERC20FailedOperation),
    }
    #[automatically_derived]
    impl AaveLooperErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [20u8, 37u8, 234u8, 66u8],
            [82u8, 116u8, 175u8, 231u8],
            [153u8, 150u8, 179u8, 21u8],
            [205u8, 120u8, 96u8, 89u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for AaveLooperErrors {
        const NAME: &'static str = "AaveLooperErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressInsufficientBalance(_) => {
                    <AddressInsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedInnerCall(_) => {
                    <FailedInnerCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<AaveLooperErrors>] = &[
                {
                    fn FailedInnerCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <FailedInnerCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::FailedInnerCall)
                    }
                    FailedInnerCall
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::SafeERC20FailedOperation)
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn AddressInsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <AddressInsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::AddressInsufficientBalance)
                    }
                    AddressInsufficientBalance
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AddressInsufficientBalance(inner) => {
                    <AddressInsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedInnerCall(inner) => {
                    <FailedInnerCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressInsufficientBalance(inner) => {
                    <AddressInsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedInnerCall(inner) => {
                    <FailedInnerCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`AaveLooper`](self) contract instance.

See the [wrapper's documentation](`AaveLooperInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> AaveLooperInstance<T, P, N> {
        AaveLooperInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        owner: alloy::sol_types::private::Address,
        asset: alloy::sol_types::private::Address,
        lendingPool: alloy::sol_types::private::Address,
        incentives: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<AaveLooperInstance<T, P, N>>,
    > {
        AaveLooperInstance::<
            T,
            P,
            N,
        >::deploy(provider, owner, asset, lendingPool, incentives)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        owner: alloy::sol_types::private::Address,
        asset: alloy::sol_types::private::Address,
        lendingPool: alloy::sol_types::private::Address,
        incentives: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        AaveLooperInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, owner, asset, lendingPool, incentives)
    }
    /**A [`AaveLooper`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`AaveLooper`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct AaveLooperInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for AaveLooperInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("AaveLooperInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AaveLooperInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`AaveLooper`](self) contract instance.

See the [wrapper's documentation](`AaveLooperInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            owner: alloy::sol_types::private::Address,
            asset: alloy::sol_types::private::Address,
            lendingPool: alloy::sol_types::private::Address,
            incentives: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<AaveLooperInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                owner,
                asset,
                lendingPool,
                incentives,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            owner: alloy::sol_types::private::Address,
            asset: alloy::sol_types::private::Address,
            lendingPool: alloy::sol_types::private::Address,
            incentives: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            owner,
                            asset,
                            lendingPool,
                            incentives,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> AaveLooperInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> AaveLooperInstance<T, P, N> {
            AaveLooperInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AaveLooperInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ASSET`] function.
        pub fn ASSET(&self) -> alloy_contract::SolCallBuilder<T, &P, ASSETCall, N> {
            self.call_builder(&ASSETCall {})
        }
        ///Creates a new call builder for the [`INCENTIVES`] function.
        pub fn INCENTIVES(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INCENTIVESCall, N> {
            self.call_builder(&INCENTIVESCall {})
        }
        ///Creates a new call builder for the [`LENDING_POOL`] function.
        pub fn LENDING_POOL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LENDING_POOLCall, N> {
            self.call_builder(&LENDING_POOLCall {})
        }
        ///Creates a new call builder for the [`OWNER`] function.
        pub fn OWNER(&self) -> alloy_contract::SolCallBuilder<T, &P, OWNERCall, N> {
            self.call_builder(&OWNERCall {})
        }
        ///Creates a new call builder for the [`SAFE_BUFFER`] function.
        pub fn SAFE_BUFFER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SAFE_BUFFERCall, N> {
            self.call_builder(&SAFE_BUFFERCall {})
        }
        ///Creates a new call builder for the [`USE_VARIABLE_DEBT`] function.
        pub fn USE_VARIABLE_DEBT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, USE_VARIABLE_DEBTCall, N> {
            self.call_builder(&USE_VARIABLE_DEBTCall {})
        }
        ///Creates a new call builder for the [`_borrow`] function.
        pub fn _borrow(
            &self,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _borrowCall, N> {
            self.call_builder(&_borrowCall { amount })
        }
        ///Creates a new call builder for the [`_redeemSupply`] function.
        pub fn _redeemSupply(
            &self,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _redeemSupplyCall, N> {
            self.call_builder(&_redeemSupplyCall { amount })
        }
        ///Creates a new call builder for the [`_repayBorrow`] function.
        pub fn _repayBorrow(
            &self,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _repayBorrowCall, N> {
            self.call_builder(&_repayBorrowCall { amount })
        }
        ///Creates a new call builder for the [`_supply`] function.
        pub fn _supply(
            &self,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _supplyCall, N> {
            self.call_builder(&_supplyCall { amount })
        }
        ///Creates a new call builder for the [`_withdrawToOwner`] function.
        pub fn _withdrawToOwner(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, _withdrawToOwnerCall, N> {
            self.call_builder(&_withdrawToOwnerCall { asset })
        }
        ///Creates a new call builder for the [`claimRewardsToOwner`] function.
        pub fn claimRewardsToOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimRewardsToOwnerCall, N> {
            self.call_builder(&claimRewardsToOwnerCall {})
        }
        ///Creates a new call builder for the [`emergencyFunctionCall`] function.
        pub fn emergencyFunctionCall(
            &self,
            target: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, emergencyFunctionCallCall, N> {
            self.call_builder(
                &emergencyFunctionCallCall {
                    target,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`emergencyFunctionDelegateCall`] function.
        pub fn emergencyFunctionDelegateCall(
            &self,
            target: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            emergencyFunctionDelegateCallCall,
            N,
        > {
            self.call_builder(
                &emergencyFunctionDelegateCallCall {
                    target,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`enterPosition`] function.
        pub fn enterPosition(
            &self,
            principal: alloy::sol_types::private::U256,
            iterations: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, enterPositionCall, N> {
            self.call_builder(
                &enterPositionCall {
                    principal,
                    iterations,
                },
            )
        }
        ///Creates a new call builder for the [`enterPositionFully`] function.
        pub fn enterPositionFully(
            &self,
            iterations: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, enterPositionFullyCall, N> {
            self.call_builder(
                &enterPositionFullyCall {
                    iterations,
                },
            )
        }
        ///Creates a new call builder for the [`exitPosition`] function.
        pub fn exitPosition(
            &self,
            iterations: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, exitPositionCall, N> {
            self.call_builder(&exitPositionCall { iterations })
        }
        ///Creates a new call builder for the [`getAssetBalance`] function.
        pub fn getAssetBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAssetBalanceCall, N> {
            self.call_builder(&getAssetBalanceCall {})
        }
        ///Creates a new call builder for the [`getAssetPrice`] function.
        pub fn getAssetPrice(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAssetPriceCall, N> {
            self.call_builder(&getAssetPriceCall {})
        }
        ///Creates a new call builder for the [`getBorrowBalance`] function.
        pub fn getBorrowBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBorrowBalanceCall, N> {
            self.call_builder(&getBorrowBalanceCall {})
        }
        ///Creates a new call builder for the [`getLTV`] function.
        pub fn getLTV(&self) -> alloy_contract::SolCallBuilder<T, &P, getLTVCall, N> {
            self.call_builder(&getLTVCall {})
        }
        ///Creates a new call builder for the [`getLiquidity`] function.
        pub fn getLiquidity(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLiquidityCall, N> {
            self.call_builder(&getLiquidityCall {})
        }
        ///Creates a new call builder for the [`getPendingRewards`] function.
        pub fn getPendingRewards(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPendingRewardsCall, N> {
            self.call_builder(&getPendingRewardsCall {})
        }
        ///Creates a new call builder for the [`getPositionData`] function.
        pub fn getPositionData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPositionDataCall, N> {
            self.call_builder(&getPositionDataCall {})
        }
        ///Creates a new call builder for the [`getSupplyAndBorrowAssets`] function.
        pub fn getSupplyAndBorrowAssets(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSupplyAndBorrowAssetsCall, N> {
            self.call_builder(&getSupplyAndBorrowAssetsCall {})
        }
        ///Creates a new call builder for the [`getSupplyBalance`] function.
        pub fn getSupplyBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSupplyBalanceCall, N> {
            self.call_builder(&getSupplyBalanceCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AaveLooperInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
