/**

Generated by the following Solidity interface...
```solidity
interface AaveLooper {
    error AddressEmptyCode(address target);
    error AddressInsufficientBalance(address account);
    error FailedInnerCall();
    error SafeERC20FailedOperation(address token);

    constructor(address owner, address lendingPool, address wethAddress, address uniswapV3Router);

    function AGGREGATION_ROUTER_V5() external view returns (address);
    function FEE_TIERS(uint256) external view returns (uint24);
    function LENDING_POOL() external view returns (address);
    function OWNER() external view returns (address);
    function SAFE_BUFFER() external view returns (uint256);
    function UNISWAP_V3_FACTORY() external view returns (address);
    function UNISWAP_V3_ROUTER() external view returns (address);
    function USE_VARIABLE_DEBT() external view returns (uint256);
    function WETH_ADDRESS() external view returns (address);
    function _borrow(address asset, uint256 amount) external;
    function _redeemSupply(address asset, uint256 amount) external;
    function _repayBorrow(address asset, uint256 amount) external;
    function _supply(address asset, uint256 amount) external;
    function _withdrawToOwner(address asset) external returns (uint256);
    function emergencyFunctionCall(address target, bytes memory data) external;
    function emergencyFunctionDelegateCall(address target, bytes memory data) external;
    function executeOperation(address asset, uint256 amount, uint256 premium, address initiator, bytes memory params) external returns (bool);
    function exitPosition(address supplyAsset, address borrowAsset, uint256 maxIterations, uint24 feeTier) external returns (uint256);
    function exitPositionWithFlashLoan(address supplyAsset, address borrowAsset) external returns (uint256);
    function getAssetBalance(address asset) external view returns (uint256);
    function getAssetPrice(address asset) external view returns (uint256);
    function getAvailableBorrowAmount(address asset) external view returns (uint256);
    function getBestFeeTier(address factory, address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint24 bestFeeTier, uint256 amountOut);
    function getBorrowBalance(address asset) external view returns (uint256);
    function getDerivedAssets(address asset) external view returns (address[] memory assets);
    function getLTV(address asset) external view returns (uint256);
    function getLiquidity(address asset) external view returns (uint256);
    function getPositionData() external view returns (uint256 totalCollateral, uint256 totalDebt, uint256 availableBorrows, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor);
    function getSupplyBalance(address asset) external view returns (uint256);
    function leverage(address supplyAsset, address borrowAsset, uint256 principal, uint256 iterations, uint24 feeTier) external returns (uint256);
    function leverageFully(address supplyAsset, address borrowAsset, uint256 iterations, uint24 feeTier) external returns (uint256);
    function swapUniswapV3(address tokenIn, address tokenOut, uint256 amountIn, uint24 feeTier) external returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "lendingPool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "wethAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "uniswapV3Router",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "AGGREGATION_ROUTER_V5",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "FEE_TIERS",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LENDING_POOL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IPool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "OWNER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SAFE_BUFFER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UNISWAP_V3_FACTORY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UNISWAP_V3_ROUTER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "USE_VARIABLE_DEBT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "WETH_ADDRESS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "_borrow",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_redeemSupply",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_repayBorrow",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_supply",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "_withdrawToOwner",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "emergencyFunctionCall",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "emergencyFunctionDelegateCall",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "executeOperation",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "premium",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "initiator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "params",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "exitPosition",
    "inputs": [
      {
        "name": "supplyAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "borrowAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxIterations",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "feeTier",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "exitPositionWithFlashLoan",
    "inputs": [
      {
        "name": "supplyAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "borrowAsset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getAssetBalance",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAssetPrice",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAvailableBorrowAmount",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBestFeeTier",
    "inputs": [
      {
        "name": "factory",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenIn",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "bestFeeTier",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "amountOut",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBorrowBalance",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDerivedAssets",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "assets",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLTV",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLiquidity",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPositionData",
    "inputs": [],
    "outputs": [
      {
        "name": "totalCollateral",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "totalDebt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "availableBorrows",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "currentLiquidationThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "ltv",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "healthFactor",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSupplyBalance",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leverage",
    "inputs": [
      {
        "name": "supplyAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "borrowAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "principal",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "iterations",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "feeTier",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "leverageFully",
    "inputs": [
      {
        "name": "supplyAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "borrowAsset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "iterations",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "feeTier",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "swapUniswapV3",
    "inputs": [
      {
        "name": "tokenIn",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "feeTier",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressInsufficientBalance",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "FailedInnerCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod AaveLooper {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6101a060405260646101209081526101f461014052610bb8610160526127106101805261003090600090600461014b565b5034801561003d57600080fd5b50604051612cff380380612cff83398101604081905261005c91610227565b836001600160a01b0381166100a25760405162461bcd60e51b815260206004820152600760248201526606f776e657220360cc1b60448201526064015b60405180910390fd5b6001600160a01b0390811660805283166100ea5760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b6044820152606401610099565b6001600160a01b03811661012c5760405162461bcd60e51b815260206004820152600960248201526806164647265737320360bc1b6044820152606401610099565b6001600160a01b0392831660a052908216610100521660c0525061027b565b82805482825590600052602060002090600901600a900481019282156101e65791602002820160005b838211156101b557835183826101000a81548162ffffff021916908361ffff1602179055509260200192600301602081600201049283019260010302610174565b80156101e45782816101000a81549062ffffff02191690556003016020816002010492830192600103026101b5565b505b506101f29291506101f6565b5090565b5b808211156101f257600081556001016101f7565b80516001600160a01b038116811461022257600080fd5b919050565b6000806000806080858703121561023d57600080fd5b6102468561020b565b93506102546020860161020b565b92506102626040860161020b565b91506102706060860161020b565b905092959194509250565b60805160a05160c05160e0516101005161297c61038360003960006101fa015260006105240152600081816102d101528181610b960152610c8d015260008181610430015281816105a80152818161068f015281816107a001528181610d4a01528181611324015281816113a00152818161154e015281816115a6015281816116880152818161173901528181611959015281816119b10152611a5c01526000818161025f015281816105530152818161083c0152818161089501528181610a4f01528181610b0801528181610b4201528181610e97015281816115020152818161161f015281816116c20152818161184e0152818161190d01526119eb015261297c6000f3fe608060405234801561001057600080fd5b50600436106101f05760003560e01c8063a210e4331161010f578063c7a0b618116100a2578063e78d73ad11610071578063e78d73ad146104c4578063e8f37963146104d7578063f38e266a1461050c578063f73e5aab1461051f57600080fd5b8063c7a0b61814610478578063ca7453d41461048b578063cce1cd6d1461049e578063e36338db146104b157600080fd5b8063b3596f07116100de578063b3596f0714610418578063b4dcfc771461042b578063b4f8b07b14610452578063bca7a4601461046557600080fd5b8063a210e433146103a9578063a747b93b146103d7578063aca25f9a146103ea578063b11de7e3146103fd57600080fd5b80635886e7c1116101875780636b1b9b20116101565780636b1b9b2014610354578063756695511461037b5780637d6af0791461038e5780638a0ccf6c146103a157600080fd5b80635886e7c1146103065780635ddfbc5b146103195780635f6a18db1461032157806369c812ba1461033457600080fd5b80632ab0aabb116101c35780632ab0aabb146102a4578063329ef6df146102b957806341c64a2f146102cc5780635373433f146102f357600080fd5b8063040141e5146101f55780630d7de37f14610239578063117803e31461025a5780631b11d0ff14610281575b600080fd5b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b61024c610247366004611f5c565b610546565b604051908152602001610230565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b61029461028f366004611f95565b610682565b6040519015158152602001610230565b6102b76102b23660046120b3565b610831565b005b61024c6102c7366004612173565b610888565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b61024c6103013660046121ce565b6109d7565b61024c6103143660046121ce565b610a42565b61024c600281565b61024c61032f3660046121eb565b610b35565b6103476103423660046121ce565b610d25565b604051610230919061223c565b610367610362366004612288565b610e51565b60405162ffffff9091168152602001610230565b61024c6103893660046121eb565b610e8a565b61024c61039c3660046121ce565b610f9f565b61024c606481565b6103bc6103b73660046122a1565b61104a565b6040805162ffffff9093168352602083019190915201610230565b61024c6103e53660046121ce565b611252565b61024c6103f83660046121ce565b611300565b61021c731111111254eeb25477b68fb85ed929f73a96058281565b61024c6104263660046121ce565b61139b565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b6102b76104603660046122f2565b6114f7565b6102b76104733660046122f2565b611614565b6102b76104863660046122f2565b6116b7565b61024c6104993660046121ce565b61179a565b61024c6104ac3660046121eb565b611841565b6102b76104bf3660046122f2565b611902565b6102b76104d23660046120b3565b6119e0565b6104df611a32565b604080519687526020870195909552938501929092526060840152608083015260a082015260c001610230565b61024c61051a3660046121ce565b611ada565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105995760405162461bcd60e51b81526004016105909061231e565b60405180910390fd5b60006105a483610f9f565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166342b0b77c30858488886040516020016106009291906001600160a01b0392831681529116602082015260400190565b60405160208183030381529060405260006040518663ffffffff1660e01b8152600401610631959493929190612365565b600060405180830381600087803b15801561064b57600080fd5b505af115801561065f573d6000803e3d6000fd5b5050505061066f84600019611614565b61067884610a42565b9150505b92915050565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106fc5760405162461bcd60e51b815260206004820152601b60248201527f43616c6c6572206d757374206265206c656e64696e6720706f6f6c00000000006044820152606401610590565b6001600160a01b03841630146107545760405162461bcd60e51b815260206004820152601f60248201527f496e69746961746f72206d757374206265207468697320636f6e7472616374006044820152606401610590565b60008061076384860186611f5c565b9150915061077181896114f7565b61077d82600019611614565b6000610789888a6123df565b60405163095ea7b360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052919250908b169063095ea7b3906044016020604051808303816000875af11580156107fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108209190612402565b5060019a9950505050505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146108795760405162461bcd60e51b81526004016105909061231e565b6108838282611b2c565b505050565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146108d25760405162461bcd60e51b81526004016105909061231e565b8315610951576040516323b872dd60e01b8152336004820152306024820152604481018590526001600160a01b038716906323b872dd906064016020604051808303816000875af115801561092b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094f9190612402565b505b600061095c876109d7565b111561096f5761096f866104bf886109d7565b60005b838110156109c3576109938660646109898961179a565b610486919061241d565b600061099e876109d7565b90506109ac87898387610b35565b506109ba886104bf8a6109d7565b50600101610972565b506109cd86611252565b9695505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610a1e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067c9190612430565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610a8c5760405162461bcd60e51b81526004016105909061231e565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa158015610ad3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610af79190612430565b9050610b2d6001600160a01b0384167f000000000000000000000000000000000000000000000000000000000000000083611b99565b90505b919050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b7f5760405162461bcd60e51b81526004016105909061231e565b60405163095ea7b360e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820185905286169063095ea7b3906044016020604051808303816000875af1158015610bee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c129190612402565b506000604051806101000160405280876001600160a01b03168152602001866001600160a01b031681526020018462ffffff168152602001306001600160a01b031681526020014261012c610c6791906123df565b81526020018581526020016001815260200160006001600160a01b0316815250905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663414bf389836040518263ffffffff1660e01b8152600401610cd79190612449565b6020604051808303816000875af1158015610cf6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1a9190612430565b979650505050505050565b6040516335ea6a7560e01b81526001600160a01b0382811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610d92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db69190612553565b604080516002808252606082018352929350919060208301908036833701905050915080610100015182600081518110610df257610df261267f565b60200260200101906001600160a01b031690816001600160a01b03168152505080610140015182600181518110610e2b57610e2b61267f565b60200260200101906001600160a01b031690816001600160a01b03168152505050919050565b60008181548110610e6157600080fd5b90600052602060002090600a9182820401919006600302915054906101000a900462ffffff1681565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ed45760405162461bcd60e51b81526004016105909061231e565b600080610edf611a32565b509450505092505060005b61271083118015610efa57508581105b15610f6e57610f2f88606484610f0f8c611252565b610f1b90612710612695565b610f2591906126ac565b610473919061241d565b610f438888610f3d8b6109d7565b88610b35565b50610f5187610460896109d7565b610f5a87610f9f565b925080610f66816126ce565b915050610eea565b610f7787610f9f565b600003610f8a57610f8a88600019611614565b610f9388610a42565b98975050505050505050565b600080610faa611a32565b505050509150506000836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ff1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061101591906126f8565b60ff1690506110238461139b565b61102e82600a6127fa565b6110389084612695565b61104291906126ac565b949350505050565b60008060005b600054811015611248576000876001600160a01b0316631698ee828888600086815481106110805761108061267f565b60009182526020909120600a8083049091015460405160e087901b6001600160e01b03191681526001600160a01b03958616600482015293909416602484015290066003026101000a90910462ffffff166044820152606401602060405180830381865afa1580156110f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111a9190612806565b90506001600160a01b0381166111305750611240565b6000816001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa158015611170573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111949190612823565b5050505050509050600060c0826001600160a01b0316836001600160a01b03166111be9190612695565b6111d090670de0b6b3a7640000612695565b901c90506000670de0b6b3a76400006111e9838a612695565b6111f391906126ac565b90508581111561123b57600085815481106112105761121061267f565b90600052602060002090600a91828204019190066003029054906101000a900462ffffff1696508095505b505050505b600101611050565b5094509492505050565b60008061125d611a32565b50505092505050600061126f8461139b565b90506000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156112b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112d591906126f8565b9050816112e382600a6128b5565b6112ed9085612695565b6112f791906126ac565b95945050505050565b60405163c44b11f760e01b81526001600160a01b03828116600483015260009182917f0000000000000000000000000000000000000000000000000000000000000000169063c44b11f790602401602060405180830381865afa15801561136b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061138f91906128c4565b5161ffff169392505050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316630542975c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114209190612806565b9050806001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611460573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114849190612806565b60405163b3596f0760e01b81526001600160a01b038581166004830152919091169063b3596f0790602401602060405180830381865afa1580156114cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114f09190612430565b9392505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461153f5760405162461bcd60e51b81526004016105909061231e565b6115736001600160a01b0383167f000000000000000000000000000000000000000000000000000000000000000083611bf8565b60405163573ade8160e01b81526001600160a01b03838116600483015260248201839052600260448301523060648301527f0000000000000000000000000000000000000000000000000000000000000000169063573ade81906084015b6020604051808303816000875af11580156115f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108839190612430565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461165c5760405162461bcd60e51b81526004016105909061231e565b604051631a4ca37b60e21b81526001600160a01b038381166004830152602482018390523060448301527f000000000000000000000000000000000000000000000000000000000000000016906369328dec906064016115d1565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146116ff5760405162461bcd60e51b81526004016105909061231e565b60405163a415bcad60e01b81526001600160a01b0383811660048301526024820183905260026044830152600060648301523060848301527f0000000000000000000000000000000000000000000000000000000000000000169063a415bcad9060a4015b600060405180830381600087803b15801561177e57600080fd5b505af1158015611792573d6000803e3d6000fd5b505050505050565b6000806117a5611a32565b5050509250505060006117b78461139b565b90506000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156117f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061181d91906126f8565b905060008261182d83600a6128b5565b6118379086612695565b6109cd91906126ac565b6000336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461188b5760405162461bcd60e51b81526004016105909061231e565b6040516370a0823160e01b81523360048201526112f790869086906001600160a01b038316906370a0823190602401602060405180830381865afa1580156118d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118fb9190612430565b8686610888565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461194a5760405162461bcd60e51b81526004016105909061231e565b61197e6001600160a01b0383167f000000000000000000000000000000000000000000000000000000000000000083611bf8565b60405163e8eda9df60e01b81526001600160a01b03838116600483015260248201839052306044830152600060648301527f0000000000000000000000000000000000000000000000000000000000000000169063e8eda9df90608401611764565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611a285760405162461bcd60e51b81526004016105909061231e565b6108838282611c88565b604051632fe4a15f60e21b8152306004820152600090819081908190819081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063bf92857c9060240160c060405180830381865afa158015611aa3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac791906128e0565b949b939a50919850965094509092509050565b600080611ae5611a32565b505050505090506000836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ff1573d6000803e3d6000fd5b6060600080846001600160a01b031684604051611b49919061292a565b600060405180830381855af49150503d8060008114611b84576040519150601f19603f3d011682016040523d82523d6000602084013e611b89565b606091505b50915091506112f7858383611c96565b6040516001600160a01b0383811660248301526044820183905261088391859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611cf2565b604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301526000919085169063dd62ed3e90604401602060405180830381865afa158015611c48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6c9190612430565b9050611c828484611c7d85856123df565b611d55565b50505050565b60606114f083836000611de5565b606082611cab57611ca682611e78565b6114f0565b8151158015611cc257506001600160a01b0384163b155b15611ceb57604051639996b31560e01b81526001600160a01b0385166004820152602401610590565b5092915050565b6000611d076001600160a01b03841683611c88565b90508051600014158015611d2c575080806020019051810190611d2a9190612402565b155b1561088357604051635274afe760e01b81526001600160a01b0384166004820152602401610590565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b179052611da68482611ea4565b611c82576040516001600160a01b03848116602483015260006044830152611ddb91869182169063095ea7b390606401611bc6565b611c828482611cf2565b606081471015611e0a5760405163cd78605960e01b8152306004820152602401610590565b600080856001600160a01b03168486604051611e26919061292a565b60006040518083038185875af1925050503d8060008114611e63576040519150601f19603f3d011682016040523d82523d6000602084013e611e68565b606091505b50915091506109cd868383611c96565b805115611e885780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b50565b6000806000846001600160a01b031684604051611ec1919061292a565b6000604051808303816000865af19150503d8060008114611efe576040519150601f19603f3d011682016040523d82523d6000602084013e611f03565b606091505b5091509150818015611f2d575080511580611f2d575080806020019051810190611f2d9190612402565b80156112f75750505050506001600160a01b03163b151590565b6001600160a01b0381168114611ea157600080fd5b60008060408385031215611f6f57600080fd5b8235611f7a81611f47565b91506020830135611f8a81611f47565b809150509250929050565b60008060008060008060a08789031215611fae57600080fd5b8635611fb981611f47565b955060208701359450604087013593506060870135611fd781611f47565b9250608087013567ffffffffffffffff811115611ff357600080fd5b8701601f8101891361200457600080fd5b803567ffffffffffffffff81111561201b57600080fd5b89602082840101111561202d57600080fd5b60208201935080925050509295509295509295565b634e487b7160e01b600052604160045260246000fd5b6040516101e0810167ffffffffffffffff8111828210171561207c5761207c612042565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156120ab576120ab612042565b604052919050565b600080604083850312156120c657600080fd5b82356120d181611f47565b9150602083013567ffffffffffffffff8111156120ed57600080fd5b8301601f810185136120fe57600080fd5b803567ffffffffffffffff81111561211857612118612042565b61212b601f8201601f1916602001612082565b81815286602083850101111561214057600080fd5b816020840160208301376000602083830101528093505050509250929050565b803562ffffff81168114610b3057600080fd5b600080600080600060a0868803121561218b57600080fd5b853561219681611f47565b945060208601356121a681611f47565b935060408601359250606086013591506121c260808701612160565b90509295509295909350565b6000602082840312156121e057600080fd5b81356114f081611f47565b6000806000806080858703121561220157600080fd5b843561220c81611f47565b9350602085013561221c81611f47565b92506040850135915061223160608601612160565b905092959194509250565b602080825282518282018190526000918401906040840190835b8181101561227d5783516001600160a01b0316835260209384019390920191600101612256565b509095945050505050565b60006020828403121561229a57600080fd5b5035919050565b600080600080608085870312156122b757600080fd5b84356122c281611f47565b935060208501356122d281611f47565b925060408501356122e281611f47565b9396929550929360600135925050565b6000806040838503121561230557600080fd5b823561231081611f47565b946020939093013593505050565b60208082526009908201526837b7363ca7bbb732b960b91b604082015260600190565b60005b8381101561235c578181015183820152602001612344565b50506000910152565b60018060a01b038616815260018060a01b038516602082015283604082015260a06060820152600083518060a08401526123a68160c0850160208801612341565b61ffff93909316608083015250601f91909101601f19160160c001949350505050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561067c5761067c6123c9565b80518015158114610b3057600080fd5b60006020828403121561241457600080fd5b6114f0826123f2565b8181038181111561067c5761067c6123c9565b60006020828403121561244257600080fd5b5051919050565b81516001600160a01b03908116825260208084015182169083015260408084015162ffffff169083015260608084015191821690830152610100820190506080830151608083015260a083015160a083015260c083015160c083015260e0830151611ceb60e08401826001600160a01b03169052565b6000602082840312156124d157600080fd5b6040516020810167ffffffffffffffff811182821017156124f4576124f4612042565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff81168114610b3057600080fd5b805164ffffffffff81168114610b3057600080fd5b805161ffff81168114610b3057600080fd5b8051610b3081611f47565b60006101e082840312801561256757600080fd5b50612570612058565b61257a84846124bf565b815261258860208401612501565b602082015261259960408401612501565b60408201526125aa60608401612501565b60608201526125bb60808401612501565b60808201526125cc60a08401612501565b60a08201526125dd60c08401612521565b60c08201526125ee60e08401612536565b60e08201526126006101008401612548565b6101008201526126136101208401612548565b6101208201526126266101408401612548565b6101408201526126396101608401612548565b61016082015261264c6101808401612501565b61018082015261265f6101a08401612501565b6101a08201526126726101c08401612501565b6101c08201529392505050565b634e487b7160e01b600052603260045260246000fd5b808202811582820484141761067c5761067c6123c9565b6000826126c957634e487b7160e01b600052601260045260246000fd5b500490565b6000600182016126e0576126e06123c9565b5060010190565b805160ff81168114610b3057600080fd5b60006020828403121561270a57600080fd5b6114f0826126e7565b6001815b600184111561274e57808504811115612732576127326123c9565b600184161561274057908102905b60019390931c928002612717565b935093915050565b6000826127655750600161067c565b816127725750600061067c565b81600181146127885760028114612792576127ae565b600191505061067c565b60ff8411156127a3576127a36123c9565b50506001821b61067c565b5060208310610133831016604e8410600b84101617156127d1575081810a61067c565b6127de6000198484612713565b80600019048211156127f2576127f26123c9565b029392505050565b60006114f08383612756565b60006020828403121561281857600080fd5b81516114f081611f47565b600080600080600080600060e0888a03121561283e57600080fd5b875161284981611f47565b8097505060208801518060020b811461286157600080fd5b955061286f60408901612536565b945061287d60608901612536565b935061288b60808901612536565b925061289960a089016126e7565b91506128a760c089016123f2565b905092959891949750929550565b60006114f060ff841683612756565b6000602082840312156128d657600080fd5b6114f083836124bf565b60008060008060008060c087890312156128f957600080fd5b50508451602086015160408701516060880151608089015160a090990151939a929950909790965094509092509050565b6000825161293c818460208701612341565b919091019291505056fea2646970667358221220c0db290aa3ff0444962ca5a05c8739a0849dd60b7c036eac1d4adee6ed6af25e64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\xA0`@R`da\x01 \x90\x81Ra\x01\xF4a\x01@Ra\x0B\xB8a\x01`Ra'\x10a\x01\x80Ra\x000\x90`\0\x90`\x04a\x01KV[P4\x80\x15a\0=W`\0\x80\xFD[P`@Qa,\xFF8\x03\x80a,\xFF\x839\x81\x01`@\x81\x90Ra\0\\\x91a\x02'V[\x83`\x01`\x01`\xA0\x1B\x03\x81\x16a\0\xA2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x07`$\x82\x01Rf\x06\xF7v\xE6W\"\x03`\xCC\x1B`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`\x80R\x83\x16a\0\xEAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rh\x06\x16FG&W72\x03`\xBC\x1B`D\x82\x01R`d\x01a\0\x99V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x01,W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\t`$\x82\x01Rh\x06\x16FG&W72\x03`\xBC\x1B`D\x82\x01R`d\x01a\0\x99V[`\x01`\x01`\xA0\x1B\x03\x92\x83\x16`\xA0R\x90\x82\x16a\x01\0R\x16`\xC0RPa\x02{V[\x82\x80T\x82\x82U\x90`\0R` `\0 \x90`\t\x01`\n\x90\x04\x81\x01\x92\x82\x15a\x01\xE6W\x91` \x02\x82\x01`\0[\x83\x82\x11\x15a\x01\xB5W\x83Q\x83\x82a\x01\0\n\x81T\x81b\xFF\xFF\xFF\x02\x19\x16\x90\x83a\xFF\xFF\x16\x02\x17\x90UP\x92` \x01\x92`\x03\x01` \x81`\x02\x01\x04\x92\x83\x01\x92`\x01\x03\x02a\x01tV[\x80\x15a\x01\xE4W\x82\x81a\x01\0\n\x81T\x90b\xFF\xFF\xFF\x02\x19\x16\x90U`\x03\x01` \x81`\x02\x01\x04\x92\x83\x01\x92`\x01\x03\x02a\x01\xB5V[P[Pa\x01\xF2\x92\x91Pa\x01\xF6V[P\x90V[[\x80\x82\x11\x15a\x01\xF2W`\0\x81U`\x01\x01a\x01\xF7V[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x02\"W`\0\x80\xFD[\x91\x90PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\x02=W`\0\x80\xFD[a\x02F\x85a\x02\x0BV[\x93Pa\x02T` \x86\x01a\x02\x0BV[\x92Pa\x02b`@\x86\x01a\x02\x0BV[\x91Pa\x02p``\x86\x01a\x02\x0BV[\x90P\x92\x95\x91\x94P\x92PV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa)|a\x03\x83`\09`\0a\x01\xFA\x01R`\0a\x05$\x01R`\0\x81\x81a\x02\xD1\x01R\x81\x81a\x0B\x96\x01Ra\x0C\x8D\x01R`\0\x81\x81a\x040\x01R\x81\x81a\x05\xA8\x01R\x81\x81a\x06\x8F\x01R\x81\x81a\x07\xA0\x01R\x81\x81a\rJ\x01R\x81\x81a\x13$\x01R\x81\x81a\x13\xA0\x01R\x81\x81a\x15N\x01R\x81\x81a\x15\xA6\x01R\x81\x81a\x16\x88\x01R\x81\x81a\x179\x01R\x81\x81a\x19Y\x01R\x81\x81a\x19\xB1\x01Ra\x1A\\\x01R`\0\x81\x81a\x02_\x01R\x81\x81a\x05S\x01R\x81\x81a\x08<\x01R\x81\x81a\x08\x95\x01R\x81\x81a\nO\x01R\x81\x81a\x0B\x08\x01R\x81\x81a\x0BB\x01R\x81\x81a\x0E\x97\x01R\x81\x81a\x15\x02\x01R\x81\x81a\x16\x1F\x01R\x81\x81a\x16\xC2\x01R\x81\x81a\x18N\x01R\x81\x81a\x19\r\x01Ra\x19\xEB\x01Ra)|`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x01\xF0W`\x005`\xE0\x1C\x80c\xA2\x10\xE43\x11a\x01\x0FW\x80c\xC7\xA0\xB6\x18\x11a\0\xA2W\x80c\xE7\x8Ds\xAD\x11a\0qW\x80c\xE7\x8Ds\xAD\x14a\x04\xC4W\x80c\xE8\xF3yc\x14a\x04\xD7W\x80c\xF3\x8E&j\x14a\x05\x0CW\x80c\xF7>Z\xAB\x14a\x05\x1FW`\0\x80\xFD[\x80c\xC7\xA0\xB6\x18\x14a\x04xW\x80c\xCAtS\xD4\x14a\x04\x8BW\x80c\xCC\xE1\xCDm\x14a\x04\x9EW\x80c\xE3c8\xDB\x14a\x04\xB1W`\0\x80\xFD[\x80c\xB3Yo\x07\x11a\0\xDEW\x80c\xB3Yo\x07\x14a\x04\x18W\x80c\xB4\xDC\xFCw\x14a\x04+W\x80c\xB4\xF8\xB0{\x14a\x04RW\x80c\xBC\xA7\xA4`\x14a\x04eW`\0\x80\xFD[\x80c\xA2\x10\xE43\x14a\x03\xA9W\x80c\xA7G\xB9;\x14a\x03\xD7W\x80c\xAC\xA2_\x9A\x14a\x03\xEAW\x80c\xB1\x1D\xE7\xE3\x14a\x03\xFDW`\0\x80\xFD[\x80cX\x86\xE7\xC1\x11a\x01\x87W\x80ck\x1B\x9B \x11a\x01VW\x80ck\x1B\x9B \x14a\x03TW\x80cuf\x95Q\x14a\x03{W\x80c}j\xF0y\x14a\x03\x8EW\x80c\x8A\x0C\xCFl\x14a\x03\xA1W`\0\x80\xFD[\x80cX\x86\xE7\xC1\x14a\x03\x06W\x80c]\xDF\xBC[\x14a\x03\x19W\x80c_j\x18\xDB\x14a\x03!W\x80ci\xC8\x12\xBA\x14a\x034W`\0\x80\xFD[\x80c*\xB0\xAA\xBB\x11a\x01\xC3W\x80c*\xB0\xAA\xBB\x14a\x02\xA4W\x80c2\x9E\xF6\xDF\x14a\x02\xB9W\x80cA\xC6J/\x14a\x02\xCCW\x80cSsC?\x14a\x02\xF3W`\0\x80\xFD[\x80c\x04\x01A\xE5\x14a\x01\xF5W\x80c\r}\xE3\x7F\x14a\x029W\x80c\x11x\x03\xE3\x14a\x02ZW\x80c\x1B\x11\xD0\xFF\x14a\x02\x81W[`\0\x80\xFD[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x02La\x02G6`\x04a\x1F\\V[a\x05FV[`@Q\x90\x81R` \x01a\x020V[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\x94a\x02\x8F6`\x04a\x1F\x95V[a\x06\x82V[`@Q\x90\x15\x15\x81R` \x01a\x020V[a\x02\xB7a\x02\xB26`\x04a \xB3V[a\x081V[\0[a\x02La\x02\xC76`\x04a!sV[a\x08\x88V[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02La\x03\x016`\x04a!\xCEV[a\t\xD7V[a\x02La\x03\x146`\x04a!\xCEV[a\nBV[a\x02L`\x02\x81V[a\x02La\x03/6`\x04a!\xEBV[a\x0B5V[a\x03Ga\x03B6`\x04a!\xCEV[a\r%V[`@Qa\x020\x91\x90a\"<V[a\x03ga\x03b6`\x04a\"\x88V[a\x0EQV[`@Qb\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x020V[a\x02La\x03\x896`\x04a!\xEBV[a\x0E\x8AV[a\x02La\x03\x9C6`\x04a!\xCEV[a\x0F\x9FV[a\x02L`d\x81V[a\x03\xBCa\x03\xB76`\x04a\"\xA1V[a\x10JV[`@\x80Qb\xFF\xFF\xFF\x90\x93\x16\x83R` \x83\x01\x91\x90\x91R\x01a\x020V[a\x02La\x03\xE56`\x04a!\xCEV[a\x12RV[a\x02La\x03\xF86`\x04a!\xCEV[a\x13\0V[a\x02\x1Cs\x11\x11\x11\x12T\xEE\xB2Tw\xB6\x8F\xB8^\xD9)\xF7:\x96\x05\x82\x81V[a\x02La\x04&6`\x04a!\xCEV[a\x13\x9BV[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xB7a\x04`6`\x04a\"\xF2V[a\x14\xF7V[a\x02\xB7a\x04s6`\x04a\"\xF2V[a\x16\x14V[a\x02\xB7a\x04\x866`\x04a\"\xF2V[a\x16\xB7V[a\x02La\x04\x996`\x04a!\xCEV[a\x17\x9AV[a\x02La\x04\xAC6`\x04a!\xEBV[a\x18AV[a\x02\xB7a\x04\xBF6`\x04a\"\xF2V[a\x19\x02V[a\x02\xB7a\x04\xD26`\x04a \xB3V[a\x19\xE0V[a\x04\xDFa\x1A2V[`@\x80Q\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R`\xA0\x82\x01R`\xC0\x01a\x020V[a\x02La\x05\x1A6`\x04a!\xCEV[a\x1A\xDAV[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x05\x99W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Q\x80\x91\x03\x90\xFD[`\0a\x05\xA4\x83a\x0F\x9FV[\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cB\xB0\xB7|0\x85\x84\x88\x88`@Q` \x01a\x06\0\x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\0`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x061\x95\x94\x93\x92\x91\x90a#eV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x06KW`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x06_W=`\0\x80>=`\0\xFD[PPPPa\x06o\x84`\0\x19a\x16\x14V[a\x06x\x84a\nBV[\x91PP[\x92\x91PPV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x06\xFCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCaller must be lending pool\0\0\0\0\0`D\x82\x01R`d\x01a\x05\x90V[`\x01`\x01`\xA0\x1B\x03\x84\x160\x14a\x07TW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FInitiator must be this contract\0`D\x82\x01R`d\x01a\x05\x90V[`\0\x80a\x07c\x84\x86\x01\x86a\x1F\\V[\x91P\x91Pa\x07q\x81\x89a\x14\xF7V[a\x07}\x82`\0\x19a\x16\x14V[`\0a\x07\x89\x88\x8Aa#\xDFV[`@Qc\t^\xA7\xB3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R\x91\x92P\x90\x8B\x16\x90c\t^\xA7\xB3\x90`D\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x07\xFCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08 \x91\x90a$\x02V[P`\x01\x9A\x99PPPPPPPPPPV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x08yW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x08\x83\x82\x82a\x1B,V[PPPV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x08\xD2W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[\x83\x15a\tQW`@Qc#\xB8r\xDD`\xE0\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R`D\x81\x01\x85\x90R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c#\xB8r\xDD\x90`d\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\t+W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\tO\x91\x90a$\x02V[P[`\0a\t\\\x87a\t\xD7V[\x11\x15a\toWa\to\x86a\x04\xBF\x88a\t\xD7V[`\0[\x83\x81\x10\x15a\t\xC3Wa\t\x93\x86`da\t\x89\x89a\x17\x9AV[a\x04\x86\x91\x90a$\x1DV[`\0a\t\x9E\x87a\t\xD7V[\x90Pa\t\xAC\x87\x89\x83\x87a\x0B5V[Pa\t\xBA\x88a\x04\xBF\x8Aa\t\xD7V[P`\x01\x01a\trV[Pa\t\xCD\x86a\x12RV[\x96\x95PPPPPPV[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x1EW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06|\x91\x90a$0V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\n\x8CW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xD3W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xF7\x91\x90a$0V[\x90Pa\x0B-`\x01`\x01`\xA0\x1B\x03\x84\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1B\x99V[\x90P[\x91\x90PV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0B\x7FW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qc\t^\xA7\xB3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x85\x90R\x86\x16\x90c\t^\xA7\xB3\x90`D\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x0B\xEEW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\x12\x91\x90a$\x02V[P`\0`@Q\x80a\x01\0\x01`@R\x80\x87`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x84b\xFF\xFF\xFF\x16\x81R` \x010`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01Ba\x01,a\x0Cg\x91\x90a#\xDFV[\x81R` \x01\x85\x81R` \x01`\x01\x81R` \x01`\0`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90P`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cAK\xF3\x89\x83`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xD7\x91\x90a$IV[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x0C\xF6W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x1A\x91\x90a$0V[\x97\x96PPPPPPPV[`@Qc5\xEAju`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R``\x91`\0\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c5\xEAju\x90`$\x01a\x01\xE0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB6\x91\x90a%SV[`@\x80Q`\x02\x80\x82R``\x82\x01\x83R\x92\x93P\x91\x90` \x83\x01\x90\x806\x837\x01\x90PP\x91P\x80a\x01\0\x01Q\x82`\0\x81Q\x81\x10a\r\xF2Wa\r\xF2a&\x7FV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPP\x80a\x01@\x01Q\x82`\x01\x81Q\x81\x10a\x0E+Wa\x0E+a&\x7FV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPPP\x91\x90PV[`\0\x81\x81T\x81\x10a\x0EaW`\0\x80\xFD[\x90`\0R` `\0 \x90`\n\x91\x82\x82\x04\x01\x91\x90\x06`\x03\x02\x91PT\x90a\x01\0\n\x90\x04b\xFF\xFF\xFF\x16\x81V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0E\xD4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`\0\x80a\x0E\xDFa\x1A2V[P\x94PPP\x92PP`\0[a'\x10\x83\x11\x80\x15a\x0E\xFAWP\x85\x81\x10[\x15a\x0FnWa\x0F/\x88`d\x84a\x0F\x0F\x8Ca\x12RV[a\x0F\x1B\x90a'\x10a&\x95V[a\x0F%\x91\x90a&\xACV[a\x04s\x91\x90a$\x1DV[a\x0FC\x88\x88a\x0F=\x8Ba\t\xD7V[\x88a\x0B5V[Pa\x0FQ\x87a\x04`\x89a\t\xD7V[a\x0FZ\x87a\x0F\x9FV[\x92P\x80a\x0Ff\x81a&\xCEV[\x91PPa\x0E\xEAV[a\x0Fw\x87a\x0F\x9FV[`\0\x03a\x0F\x8AWa\x0F\x8A\x88`\0\x19a\x16\x14V[a\x0F\x93\x88a\nBV[\x98\x97PPPPPPPPV[`\0\x80a\x0F\xAAa\x1A2V[PPPP\x91PP`\0\x83`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F\xF1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\x15\x91\x90a&\xF8V[`\xFF\x16\x90Pa\x10#\x84a\x13\x9BV[a\x10.\x82`\na'\xFAV[a\x108\x90\x84a&\x95V[a\x10B\x91\x90a&\xACV[\x94\x93PPPPV[`\0\x80`\0[`\0T\x81\x10\x15a\x12HW`\0\x87`\x01`\x01`\xA0\x1B\x03\x16c\x16\x98\xEE\x82\x88\x88`\0\x86\x81T\x81\x10a\x10\x80Wa\x10\x80a&\x7FV[`\0\x91\x82R` \x90\x91 `\n\x80\x83\x04\x90\x91\x01T`@Q`\xE0\x87\x90\x1B`\x01`\x01`\xE0\x1B\x03\x19\x16\x81R`\x01`\x01`\xA0\x1B\x03\x95\x86\x16`\x04\x82\x01R\x93\x90\x94\x16`$\x84\x01R\x90\x06`\x03\x02a\x01\0\n\x90\x91\x04b\xFF\xFF\xFF\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\xF6W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\x1A\x91\x90a(\x06V[\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16a\x110WPa\x12@V[`\0\x81`\x01`\x01`\xA0\x1B\x03\x16c8P\xC7\xBD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\xE0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11pW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\x94\x91\x90a(#V[PPPPPP\x90P`\0`\xC0\x82`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16a\x11\xBE\x91\x90a&\x95V[a\x11\xD0\x90g\r\xE0\xB6\xB3\xA7d\0\0a&\x95V[\x90\x1C\x90P`\0g\r\xE0\xB6\xB3\xA7d\0\0a\x11\xE9\x83\x8Aa&\x95V[a\x11\xF3\x91\x90a&\xACV[\x90P\x85\x81\x11\x15a\x12;W`\0\x85\x81T\x81\x10a\x12\x10Wa\x12\x10a&\x7FV[\x90`\0R` `\0 \x90`\n\x91\x82\x82\x04\x01\x91\x90\x06`\x03\x02\x90T\x90a\x01\0\n\x90\x04b\xFF\xFF\xFF\x16\x96P\x80\x95P[PPPP[`\x01\x01a\x10PV[P\x94P\x94\x92PPPV[`\0\x80a\x12]a\x1A2V[PPP\x92PPP`\0a\x12o\x84a\x13\x9BV[\x90P`\0\x84`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x12\xB1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x12\xD5\x91\x90a&\xF8V[\x90P\x81a\x12\xE3\x82`\na(\xB5V[a\x12\xED\x90\x85a&\x95V[a\x12\xF7\x91\x90a&\xACV[\x95\x94PPPPPV[`@Qc\xC4K\x11\xF7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R`\0\x91\x82\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xC4K\x11\xF7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13kW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\x8F\x91\x90a(\xC4V[Qa\xFF\xFF\x16\x93\x92PPPV[`\0\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x05B\x97\\`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xFCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14 \x91\x90a(\x06V[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16c\xFC\xA5\x13\xA8`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x14`W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\x84\x91\x90a(\x06V[`@Qc\xB3Yo\x07`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`\x04\x83\x01R\x91\x90\x91\x16\x90c\xB3Yo\x07\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x14\xCCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\xF0\x91\x90a$0V[\x93\x92PPPV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x15?W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x15s`\x01`\x01`\xA0\x1B\x03\x83\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1B\xF8V[`@QcW:\xDE\x81`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cW:\xDE\x81\x90`\x84\x01[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x15\xF0W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x83\x91\x90a$0V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x16\\W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qc\x1AL\xA3{`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90ci2\x8D\xEC\x90`d\x01a\x15\xD1V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x16\xFFW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qc\xA4\x15\xBC\xAD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R`\0`d\x83\x01R0`\x84\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA4\x15\xBC\xAD\x90`\xA4\x01[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x17~W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x17\x92W=`\0\x80>=`\0\xFD[PPPPPPV[`\0\x80a\x17\xA5a\x1A2V[PPP\x92PPP`\0a\x17\xB7\x84a\x13\x9BV[\x90P`\0\x84`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17\xF9W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\x1D\x91\x90a&\xF8V[\x90P`\0\x82a\x18-\x83`\na(\xB5V[a\x187\x90\x86a&\x95V[a\t\xCD\x91\x90a&\xACV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x18\x8BW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qcp\xA0\x821`\xE0\x1B\x81R3`\x04\x82\x01Ra\x12\xF7\x90\x86\x90\x86\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18\xD7W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\xFB\x91\x90a$0V[\x86\x86a\x08\x88V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x19JW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x19~`\x01`\x01`\xA0\x1B\x03\x83\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1B\xF8V[`@Qc\xE8\xED\xA9\xDF`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R`\0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xE8\xED\xA9\xDF\x90`\x84\x01a\x17dV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x1A(W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x08\x83\x82\x82a\x1C\x88V[`@Qc/\xE4\xA1_`\xE2\x1B\x81R0`\x04\x82\x01R`\0\x90\x81\x90\x81\x90\x81\x90\x81\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xBF\x92\x85|\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\xA3W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A\xC7\x91\x90a(\xE0V[\x94\x9B\x93\x9AP\x91\x98P\x96P\x94P\x90\x92P\x90PV[`\0\x80a\x1A\xE5a\x1A2V[PPPPP\x90P`\0\x83`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F\xF1W=`\0\x80>=`\0\xFD[```\0\x80\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x1BI\x91\x90a)*V[`\0`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80`\0\x81\x14a\x1B\x84W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1B\x89V[``\x91P[P\x91P\x91Pa\x12\xF7\x85\x83\x83a\x1C\x96V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`D\x82\x01\x83\x90Ra\x08\x83\x91\x85\x91\x82\x16\x90c\xA9\x05\x9C\xBB\x90`d\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x91P`\xE0\x1B` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x83\x81\x83\x16\x17\x83RPPPPa\x1C\xF2V[`@Qcn\xB1v\x9F`\xE1\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`\0\x91\x90\x85\x16\x90c\xDDb\xED>\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1CHW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1Cl\x91\x90a$0V[\x90Pa\x1C\x82\x84\x84a\x1C}\x85\x85a#\xDFV[a\x1DUV[PPPPV[``a\x14\xF0\x83\x83`\0a\x1D\xE5V[``\x82a\x1C\xABWa\x1C\xA6\x82a\x1ExV[a\x14\xF0V[\x81Q\x15\x80\x15a\x1C\xC2WP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x1C\xEBW`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x05\x90V[P\x92\x91PPV[`\0a\x1D\x07`\x01`\x01`\xA0\x1B\x03\x84\x16\x83a\x1C\x88V[\x90P\x80Q`\0\x14\x15\x80\x15a\x1D,WP\x80\x80` \x01\x90Q\x81\x01\x90a\x1D*\x91\x90a$\x02V[\x15[\x15a\x08\x83W`@QcRt\xAF\xE7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04\x82\x01R`$\x01a\x05\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90Ra\x1D\xA6\x84\x82a\x1E\xA4V[a\x1C\x82W`@Q`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`$\x83\x01R`\0`D\x83\x01Ra\x1D\xDB\x91\x86\x91\x82\x16\x90c\t^\xA7\xB3\x90`d\x01a\x1B\xC6V[a\x1C\x82\x84\x82a\x1C\xF2V[``\x81G\x10\x15a\x1E\nW`@Qc\xCDx`Y`\xE0\x1B\x81R0`\x04\x82\x01R`$\x01a\x05\x90V[`\0\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x84\x86`@Qa\x1E&\x91\x90a)*V[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x1EcW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1EhV[``\x91P[P\x91P\x91Pa\t\xCD\x86\x83\x83a\x1C\x96V[\x80Q\x15a\x1E\x88W\x80Q\x80\x82` \x01\xFD[`@Qc\n\x12\xF5!`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[`\0\x80`\0\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x1E\xC1\x91\x90a)*V[`\0`@Q\x80\x83\x03\x81`\0\x86Z\xF1\x91PP=\x80`\0\x81\x14a\x1E\xFEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1F\x03V[``\x91P[P\x91P\x91P\x81\x80\x15a\x1F-WP\x80Q\x15\x80a\x1F-WP\x80\x80` \x01\x90Q\x81\x01\x90a\x1F-\x91\x90a$\x02V[\x80\x15a\x12\xF7WPPPPP`\x01`\x01`\xA0\x1B\x03\x16;\x15\x15\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x1E\xA1W`\0\x80\xFD[`\0\x80`@\x83\x85\x03\x12\x15a\x1FoW`\0\x80\xFD[\x825a\x1Fz\x81a\x1FGV[\x91P` \x83\x015a\x1F\x8A\x81a\x1FGV[\x80\x91PP\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\xA0\x87\x89\x03\x12\x15a\x1F\xAEW`\0\x80\xFD[\x865a\x1F\xB9\x81a\x1FGV[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015a\x1F\xD7\x81a\x1FGV[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xF3W`\0\x80\xFD[\x87\x01`\x1F\x81\x01\x89\x13a \x04W`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \x1BW`\0\x80\xFD[\x89` \x82\x84\x01\x01\x11\x15a -W`\0\x80\xFD[` \x82\x01\x93P\x80\x92PPP\x92\x95P\x92\x95P\x92\x95V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`@Qa\x01\xE0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a |Wa |a BV[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a \xABWa \xABa BV[`@R\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a \xC6W`\0\x80\xFD[\x825a \xD1\x81a\x1FGV[\x91P` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \xEDW`\0\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a \xFEW`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\x18Wa!\x18a BV[a!+`\x1F\x82\x01`\x1F\x19\x16` \x01a \x82V[\x81\x81R\x86` \x83\x85\x01\x01\x11\x15a!@W`\0\x80\xFD[\x81` \x84\x01` \x83\x017`\0` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[\x805b\xFF\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[`\0\x80`\0\x80`\0`\xA0\x86\x88\x03\x12\x15a!\x8BW`\0\x80\xFD[\x855a!\x96\x81a\x1FGV[\x94P` \x86\x015a!\xA6\x81a\x1FGV[\x93P`@\x86\x015\x92P``\x86\x015\x91Pa!\xC2`\x80\x87\x01a!`V[\x90P\x92\x95P\x92\x95\x90\x93PV[`\0` \x82\x84\x03\x12\x15a!\xE0W`\0\x80\xFD[\x815a\x14\xF0\x81a\x1FGV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\"\x01W`\0\x80\xFD[\x845a\"\x0C\x81a\x1FGV[\x93P` \x85\x015a\"\x1C\x81a\x1FGV[\x92P`@\x85\x015\x91Pa\"1``\x86\x01a!`V[\x90P\x92\x95\x91\x94P\x92PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R`\0\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\"}W\x83Q`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\"VV[P\x90\x95\x94PPPPPV[`\0` \x82\x84\x03\x12\x15a\"\x9AW`\0\x80\xFD[P5\x91\x90PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\"\xB7W`\0\x80\xFD[\x845a\"\xC2\x81a\x1FGV[\x93P` \x85\x015a\"\xD2\x81a\x1FGV[\x92P`@\x85\x015a\"\xE2\x81a\x1FGV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[`\0\x80`@\x83\x85\x03\x12\x15a#\x05W`\0\x80\xFD[\x825a#\x10\x81a\x1FGV[\x94` \x93\x90\x93\x015\x93PPPV[` \x80\x82R`\t\x90\x82\x01Rh7\xB76<\xA7\xBB\xB72\xB9`\xB9\x1B`@\x82\x01R``\x01\x90V[`\0[\x83\x81\x10\x15a#\\W\x81\x81\x01Q\x83\x82\x01R` \x01a#DV[PP`\0\x91\x01RV[`\x01\x80`\xA0\x1B\x03\x86\x16\x81R`\x01\x80`\xA0\x1B\x03\x85\x16` \x82\x01R\x83`@\x82\x01R`\xA0``\x82\x01R`\0\x83Q\x80`\xA0\x84\x01Ra#\xA6\x81`\xC0\x85\x01` \x88\x01a#AV[a\xFF\xFF\x93\x90\x93\x16`\x80\x83\x01RP`\x1F\x91\x90\x91\x01`\x1F\x19\x16\x01`\xC0\x01\x94\x93PPPPV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[\x80\x82\x01\x80\x82\x11\x15a\x06|Wa\x06|a#\xC9V[\x80Q\x80\x15\x15\x81\x14a\x0B0W`\0\x80\xFD[`\0` \x82\x84\x03\x12\x15a$\x14W`\0\x80\xFD[a\x14\xF0\x82a#\xF2V[\x81\x81\x03\x81\x81\x11\x15a\x06|Wa\x06|a#\xC9V[`\0` \x82\x84\x03\x12\x15a$BW`\0\x80\xFD[PQ\x91\x90PV[\x81Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R` \x80\x84\x01Q\x82\x16\x90\x83\x01R`@\x80\x84\x01Qb\xFF\xFF\xFF\x16\x90\x83\x01R``\x80\x84\x01Q\x91\x82\x16\x90\x83\x01Ra\x01\0\x82\x01\x90P`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Qa\x1C\xEB`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\0` \x82\x84\x03\x12\x15a$\xD1W`\0\x80\xFD[`@Q` \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a$\xF4Wa$\xF4a BV[`@R\x91Q\x82RP\x91\x90PV[\x80Qo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[\x80Qd\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[\x80Qa\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[\x80Qa\x0B0\x81a\x1FGV[`\0a\x01\xE0\x82\x84\x03\x12\x80\x15a%gW`\0\x80\xFD[Pa%pa XV[a%z\x84\x84a$\xBFV[\x81Ra%\x88` \x84\x01a%\x01V[` \x82\x01Ra%\x99`@\x84\x01a%\x01V[`@\x82\x01Ra%\xAA``\x84\x01a%\x01V[``\x82\x01Ra%\xBB`\x80\x84\x01a%\x01V[`\x80\x82\x01Ra%\xCC`\xA0\x84\x01a%\x01V[`\xA0\x82\x01Ra%\xDD`\xC0\x84\x01a%!V[`\xC0\x82\x01Ra%\xEE`\xE0\x84\x01a%6V[`\xE0\x82\x01Ra&\0a\x01\0\x84\x01a%HV[a\x01\0\x82\x01Ra&\x13a\x01 \x84\x01a%HV[a\x01 \x82\x01Ra&&a\x01@\x84\x01a%HV[a\x01@\x82\x01Ra&9a\x01`\x84\x01a%HV[a\x01`\x82\x01Ra&La\x01\x80\x84\x01a%\x01V[a\x01\x80\x82\x01Ra&_a\x01\xA0\x84\x01a%\x01V[a\x01\xA0\x82\x01Ra&ra\x01\xC0\x84\x01a%\x01V[a\x01\xC0\x82\x01R\x93\x92PPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x06|Wa\x06|a#\xC9V[`\0\x82a&\xC9WcNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[P\x04\x90V[`\0`\x01\x82\x01a&\xE0Wa&\xE0a#\xC9V[P`\x01\x01\x90V[\x80Q`\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[`\0` \x82\x84\x03\x12\x15a'\nW`\0\x80\xFD[a\x14\xF0\x82a&\xE7V[`\x01\x81[`\x01\x84\x11\x15a'NW\x80\x85\x04\x81\x11\x15a'2Wa'2a#\xC9V[`\x01\x84\x16\x15a'@W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a'\x17V[\x93P\x93\x91PPV[`\0\x82a'eWP`\x01a\x06|V[\x81a'rWP`\0a\x06|V[\x81`\x01\x81\x14a'\x88W`\x02\x81\x14a'\x92Wa'\xAEV[`\x01\x91PPa\x06|V[`\xFF\x84\x11\x15a'\xA3Wa'\xA3a#\xC9V[PP`\x01\x82\x1Ba\x06|V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a'\xD1WP\x81\x81\na\x06|V[a'\xDE`\0\x19\x84\x84a'\x13V[\x80`\0\x19\x04\x82\x11\x15a'\xF2Wa'\xF2a#\xC9V[\x02\x93\x92PPPV[`\0a\x14\xF0\x83\x83a'VV[`\0` \x82\x84\x03\x12\x15a(\x18W`\0\x80\xFD[\x81Qa\x14\xF0\x81a\x1FGV[`\0\x80`\0\x80`\0\x80`\0`\xE0\x88\x8A\x03\x12\x15a(>W`\0\x80\xFD[\x87Qa(I\x81a\x1FGV[\x80\x97PP` \x88\x01Q\x80`\x02\x0B\x81\x14a(aW`\0\x80\xFD[\x95Pa(o`@\x89\x01a%6V[\x94Pa(}``\x89\x01a%6V[\x93Pa(\x8B`\x80\x89\x01a%6V[\x92Pa(\x99`\xA0\x89\x01a&\xE7V[\x91Pa(\xA7`\xC0\x89\x01a#\xF2V[\x90P\x92\x95\x98\x91\x94\x97P\x92\x95PV[`\0a\x14\xF0`\xFF\x84\x16\x83a'VV[`\0` \x82\x84\x03\x12\x15a(\xD6W`\0\x80\xFD[a\x14\xF0\x83\x83a$\xBFV[`\0\x80`\0\x80`\0\x80`\xC0\x87\x89\x03\x12\x15a(\xF9W`\0\x80\xFD[PP\x84Q` \x86\x01Q`@\x87\x01Q``\x88\x01Q`\x80\x89\x01Q`\xA0\x90\x99\x01Q\x93\x9A\x92\x99P\x90\x97\x90\x96P\x94P\x90\x92P\x90PV[`\0\x82Qa)<\x81\x84` \x87\x01a#AV[\x91\x90\x91\x01\x92\x91PPV\xFE\xA2dipfsX\"\x12 \xC0\xDB)\n\xA3\xFF\x04D\x96,\xA5\xA0\\\x879\xA0\x84\x9D\xD6\x0B|\x03n\xAC\x1DJ\xDE\xE6\xEDj\xF2^dsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106101f05760003560e01c8063a210e4331161010f578063c7a0b618116100a2578063e78d73ad11610071578063e78d73ad146104c4578063e8f37963146104d7578063f38e266a1461050c578063f73e5aab1461051f57600080fd5b8063c7a0b61814610478578063ca7453d41461048b578063cce1cd6d1461049e578063e36338db146104b157600080fd5b8063b3596f07116100de578063b3596f0714610418578063b4dcfc771461042b578063b4f8b07b14610452578063bca7a4601461046557600080fd5b8063a210e433146103a9578063a747b93b146103d7578063aca25f9a146103ea578063b11de7e3146103fd57600080fd5b80635886e7c1116101875780636b1b9b20116101565780636b1b9b2014610354578063756695511461037b5780637d6af0791461038e5780638a0ccf6c146103a157600080fd5b80635886e7c1146103065780635ddfbc5b146103195780635f6a18db1461032157806369c812ba1461033457600080fd5b80632ab0aabb116101c35780632ab0aabb146102a4578063329ef6df146102b957806341c64a2f146102cc5780635373433f146102f357600080fd5b8063040141e5146101f55780630d7de37f14610239578063117803e31461025a5780631b11d0ff14610281575b600080fd5b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b61024c610247366004611f5c565b610546565b604051908152602001610230565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b61029461028f366004611f95565b610682565b6040519015158152602001610230565b6102b76102b23660046120b3565b610831565b005b61024c6102c7366004612173565b610888565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b61024c6103013660046121ce565b6109d7565b61024c6103143660046121ce565b610a42565b61024c600281565b61024c61032f3660046121eb565b610b35565b6103476103423660046121ce565b610d25565b604051610230919061223c565b610367610362366004612288565b610e51565b60405162ffffff9091168152602001610230565b61024c6103893660046121eb565b610e8a565b61024c61039c3660046121ce565b610f9f565b61024c606481565b6103bc6103b73660046122a1565b61104a565b6040805162ffffff9093168352602083019190915201610230565b61024c6103e53660046121ce565b611252565b61024c6103f83660046121ce565b611300565b61021c731111111254eeb25477b68fb85ed929f73a96058281565b61024c6104263660046121ce565b61139b565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b6102b76104603660046122f2565b6114f7565b6102b76104733660046122f2565b611614565b6102b76104863660046122f2565b6116b7565b61024c6104993660046121ce565b61179a565b61024c6104ac3660046121eb565b611841565b6102b76104bf3660046122f2565b611902565b6102b76104d23660046120b3565b6119e0565b6104df611a32565b604080519687526020870195909552938501929092526060840152608083015260a082015260c001610230565b61024c61051a3660046121ce565b611ada565b61021c7f000000000000000000000000000000000000000000000000000000000000000081565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105995760405162461bcd60e51b81526004016105909061231e565b60405180910390fd5b60006105a483610f9f565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166342b0b77c30858488886040516020016106009291906001600160a01b0392831681529116602082015260400190565b60405160208183030381529060405260006040518663ffffffff1660e01b8152600401610631959493929190612365565b600060405180830381600087803b15801561064b57600080fd5b505af115801561065f573d6000803e3d6000fd5b5050505061066f84600019611614565b61067884610a42565b9150505b92915050565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106fc5760405162461bcd60e51b815260206004820152601b60248201527f43616c6c6572206d757374206265206c656e64696e6720706f6f6c00000000006044820152606401610590565b6001600160a01b03841630146107545760405162461bcd60e51b815260206004820152601f60248201527f496e69746961746f72206d757374206265207468697320636f6e7472616374006044820152606401610590565b60008061076384860186611f5c565b9150915061077181896114f7565b61077d82600019611614565b6000610789888a6123df565b60405163095ea7b360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000008116600483015260248201839052919250908b169063095ea7b3906044016020604051808303816000875af11580156107fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108209190612402565b5060019a9950505050505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146108795760405162461bcd60e51b81526004016105909061231e565b6108838282611b2c565b505050565b6000336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146108d25760405162461bcd60e51b81526004016105909061231e565b8315610951576040516323b872dd60e01b8152336004820152306024820152604481018590526001600160a01b038716906323b872dd906064016020604051808303816000875af115801561092b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094f9190612402565b505b600061095c876109d7565b111561096f5761096f866104bf886109d7565b60005b838110156109c3576109938660646109898961179a565b610486919061241d565b600061099e876109d7565b90506109ac87898387610b35565b506109ba886104bf8a6109d7565b50600101610972565b506109cd86611252565b9695505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610a1e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067c9190612430565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610a8c5760405162461bcd60e51b81526004016105909061231e565b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa158015610ad3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610af79190612430565b9050610b2d6001600160a01b0384167f000000000000000000000000000000000000000000000000000000000000000083611b99565b90505b919050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b7f5760405162461bcd60e51b81526004016105909061231e565b60405163095ea7b360e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820185905286169063095ea7b3906044016020604051808303816000875af1158015610bee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c129190612402565b506000604051806101000160405280876001600160a01b03168152602001866001600160a01b031681526020018462ffffff168152602001306001600160a01b031681526020014261012c610c6791906123df565b81526020018581526020016001815260200160006001600160a01b0316815250905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663414bf389836040518263ffffffff1660e01b8152600401610cd79190612449565b6020604051808303816000875af1158015610cf6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1a9190612430565b979650505050505050565b6040516335ea6a7560e01b81526001600160a01b0382811660048301526060916000917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610d92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610db69190612553565b604080516002808252606082018352929350919060208301908036833701905050915080610100015182600081518110610df257610df261267f565b60200260200101906001600160a01b031690816001600160a01b03168152505080610140015182600181518110610e2b57610e2b61267f565b60200260200101906001600160a01b031690816001600160a01b03168152505050919050565b60008181548110610e6157600080fd5b90600052602060002090600a9182820401919006600302915054906101000a900462ffffff1681565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ed45760405162461bcd60e51b81526004016105909061231e565b600080610edf611a32565b509450505092505060005b61271083118015610efa57508581105b15610f6e57610f2f88606484610f0f8c611252565b610f1b90612710612695565b610f2591906126ac565b610473919061241d565b610f438888610f3d8b6109d7565b88610b35565b50610f5187610460896109d7565b610f5a87610f9f565b925080610f66816126ce565b915050610eea565b610f7787610f9f565b600003610f8a57610f8a88600019611614565b610f9388610a42565b98975050505050505050565b600080610faa611a32565b505050509150506000836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ff1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061101591906126f8565b60ff1690506110238461139b565b61102e82600a6127fa565b6110389084612695565b61104291906126ac565b949350505050565b60008060005b600054811015611248576000876001600160a01b0316631698ee828888600086815481106110805761108061267f565b60009182526020909120600a8083049091015460405160e087901b6001600160e01b03191681526001600160a01b03958616600482015293909416602484015290066003026101000a90910462ffffff166044820152606401602060405180830381865afa1580156110f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111a9190612806565b90506001600160a01b0381166111305750611240565b6000816001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa158015611170573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111949190612823565b5050505050509050600060c0826001600160a01b0316836001600160a01b03166111be9190612695565b6111d090670de0b6b3a7640000612695565b901c90506000670de0b6b3a76400006111e9838a612695565b6111f391906126ac565b90508581111561123b57600085815481106112105761121061267f565b90600052602060002090600a91828204019190066003029054906101000a900462ffffff1696508095505b505050505b600101611050565b5094509492505050565b60008061125d611a32565b50505092505050600061126f8461139b565b90506000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156112b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112d591906126f8565b9050816112e382600a6128b5565b6112ed9085612695565b6112f791906126ac565b95945050505050565b60405163c44b11f760e01b81526001600160a01b03828116600483015260009182917f0000000000000000000000000000000000000000000000000000000000000000169063c44b11f790602401602060405180830381865afa15801561136b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061138f91906128c4565b5161ffff169392505050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316630542975c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114209190612806565b9050806001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa158015611460573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114849190612806565b60405163b3596f0760e01b81526001600160a01b038581166004830152919091169063b3596f0790602401602060405180830381865afa1580156114cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114f09190612430565b9392505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461153f5760405162461bcd60e51b81526004016105909061231e565b6115736001600160a01b0383167f000000000000000000000000000000000000000000000000000000000000000083611bf8565b60405163573ade8160e01b81526001600160a01b03838116600483015260248201839052600260448301523060648301527f0000000000000000000000000000000000000000000000000000000000000000169063573ade81906084015b6020604051808303816000875af11580156115f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108839190612430565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461165c5760405162461bcd60e51b81526004016105909061231e565b604051631a4ca37b60e21b81526001600160a01b038381166004830152602482018390523060448301527f000000000000000000000000000000000000000000000000000000000000000016906369328dec906064016115d1565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146116ff5760405162461bcd60e51b81526004016105909061231e565b60405163a415bcad60e01b81526001600160a01b0383811660048301526024820183905260026044830152600060648301523060848301527f0000000000000000000000000000000000000000000000000000000000000000169063a415bcad9060a4015b600060405180830381600087803b15801561177e57600080fd5b505af1158015611792573d6000803e3d6000fd5b505050505050565b6000806117a5611a32565b5050509250505060006117b78461139b565b90506000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156117f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061181d91906126f8565b905060008261182d83600a6128b5565b6118379086612695565b6109cd91906126ac565b6000336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461188b5760405162461bcd60e51b81526004016105909061231e565b6040516370a0823160e01b81523360048201526112f790869086906001600160a01b038316906370a0823190602401602060405180830381865afa1580156118d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118fb9190612430565b8686610888565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461194a5760405162461bcd60e51b81526004016105909061231e565b61197e6001600160a01b0383167f000000000000000000000000000000000000000000000000000000000000000083611bf8565b60405163e8eda9df60e01b81526001600160a01b03838116600483015260248201839052306044830152600060648301527f0000000000000000000000000000000000000000000000000000000000000000169063e8eda9df90608401611764565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611a285760405162461bcd60e51b81526004016105909061231e565b6108838282611c88565b604051632fe4a15f60e21b8152306004820152600090819081908190819081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063bf92857c9060240160c060405180830381865afa158015611aa3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac791906128e0565b949b939a50919850965094509092509050565b600080611ae5611a32565b505050505090506000836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ff1573d6000803e3d6000fd5b6060600080846001600160a01b031684604051611b49919061292a565b600060405180830381855af49150503d8060008114611b84576040519150601f19603f3d011682016040523d82523d6000602084013e611b89565b606091505b50915091506112f7858383611c96565b6040516001600160a01b0383811660248301526044820183905261088391859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611cf2565b604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301526000919085169063dd62ed3e90604401602060405180830381865afa158015611c48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6c9190612430565b9050611c828484611c7d85856123df565b611d55565b50505050565b60606114f083836000611de5565b606082611cab57611ca682611e78565b6114f0565b8151158015611cc257506001600160a01b0384163b155b15611ceb57604051639996b31560e01b81526001600160a01b0385166004820152602401610590565b5092915050565b6000611d076001600160a01b03841683611c88565b90508051600014158015611d2c575080806020019051810190611d2a9190612402565b155b1561088357604051635274afe760e01b81526001600160a01b0384166004820152602401610590565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b179052611da68482611ea4565b611c82576040516001600160a01b03848116602483015260006044830152611ddb91869182169063095ea7b390606401611bc6565b611c828482611cf2565b606081471015611e0a5760405163cd78605960e01b8152306004820152602401610590565b600080856001600160a01b03168486604051611e26919061292a565b60006040518083038185875af1925050503d8060008114611e63576040519150601f19603f3d011682016040523d82523d6000602084013e611e68565b606091505b50915091506109cd868383611c96565b805115611e885780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b50565b6000806000846001600160a01b031684604051611ec1919061292a565b6000604051808303816000865af19150503d8060008114611efe576040519150601f19603f3d011682016040523d82523d6000602084013e611f03565b606091505b5091509150818015611f2d575080511580611f2d575080806020019051810190611f2d9190612402565b80156112f75750505050506001600160a01b03163b151590565b6001600160a01b0381168114611ea157600080fd5b60008060408385031215611f6f57600080fd5b8235611f7a81611f47565b91506020830135611f8a81611f47565b809150509250929050565b60008060008060008060a08789031215611fae57600080fd5b8635611fb981611f47565b955060208701359450604087013593506060870135611fd781611f47565b9250608087013567ffffffffffffffff811115611ff357600080fd5b8701601f8101891361200457600080fd5b803567ffffffffffffffff81111561201b57600080fd5b89602082840101111561202d57600080fd5b60208201935080925050509295509295509295565b634e487b7160e01b600052604160045260246000fd5b6040516101e0810167ffffffffffffffff8111828210171561207c5761207c612042565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156120ab576120ab612042565b604052919050565b600080604083850312156120c657600080fd5b82356120d181611f47565b9150602083013567ffffffffffffffff8111156120ed57600080fd5b8301601f810185136120fe57600080fd5b803567ffffffffffffffff81111561211857612118612042565b61212b601f8201601f1916602001612082565b81815286602083850101111561214057600080fd5b816020840160208301376000602083830101528093505050509250929050565b803562ffffff81168114610b3057600080fd5b600080600080600060a0868803121561218b57600080fd5b853561219681611f47565b945060208601356121a681611f47565b935060408601359250606086013591506121c260808701612160565b90509295509295909350565b6000602082840312156121e057600080fd5b81356114f081611f47565b6000806000806080858703121561220157600080fd5b843561220c81611f47565b9350602085013561221c81611f47565b92506040850135915061223160608601612160565b905092959194509250565b602080825282518282018190526000918401906040840190835b8181101561227d5783516001600160a01b0316835260209384019390920191600101612256565b509095945050505050565b60006020828403121561229a57600080fd5b5035919050565b600080600080608085870312156122b757600080fd5b84356122c281611f47565b935060208501356122d281611f47565b925060408501356122e281611f47565b9396929550929360600135925050565b6000806040838503121561230557600080fd5b823561231081611f47565b946020939093013593505050565b60208082526009908201526837b7363ca7bbb732b960b91b604082015260600190565b60005b8381101561235c578181015183820152602001612344565b50506000910152565b60018060a01b038616815260018060a01b038516602082015283604082015260a06060820152600083518060a08401526123a68160c0850160208801612341565b61ffff93909316608083015250601f91909101601f19160160c001949350505050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561067c5761067c6123c9565b80518015158114610b3057600080fd5b60006020828403121561241457600080fd5b6114f0826123f2565b8181038181111561067c5761067c6123c9565b60006020828403121561244257600080fd5b5051919050565b81516001600160a01b03908116825260208084015182169083015260408084015162ffffff169083015260608084015191821690830152610100820190506080830151608083015260a083015160a083015260c083015160c083015260e0830151611ceb60e08401826001600160a01b03169052565b6000602082840312156124d157600080fd5b6040516020810167ffffffffffffffff811182821017156124f4576124f4612042565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff81168114610b3057600080fd5b805164ffffffffff81168114610b3057600080fd5b805161ffff81168114610b3057600080fd5b8051610b3081611f47565b60006101e082840312801561256757600080fd5b50612570612058565b61257a84846124bf565b815261258860208401612501565b602082015261259960408401612501565b60408201526125aa60608401612501565b60608201526125bb60808401612501565b60808201526125cc60a08401612501565b60a08201526125dd60c08401612521565b60c08201526125ee60e08401612536565b60e08201526126006101008401612548565b6101008201526126136101208401612548565b6101208201526126266101408401612548565b6101408201526126396101608401612548565b61016082015261264c6101808401612501565b61018082015261265f6101a08401612501565b6101a08201526126726101c08401612501565b6101c08201529392505050565b634e487b7160e01b600052603260045260246000fd5b808202811582820484141761067c5761067c6123c9565b6000826126c957634e487b7160e01b600052601260045260246000fd5b500490565b6000600182016126e0576126e06123c9565b5060010190565b805160ff81168114610b3057600080fd5b60006020828403121561270a57600080fd5b6114f0826126e7565b6001815b600184111561274e57808504811115612732576127326123c9565b600184161561274057908102905b60019390931c928002612717565b935093915050565b6000826127655750600161067c565b816127725750600061067c565b81600181146127885760028114612792576127ae565b600191505061067c565b60ff8411156127a3576127a36123c9565b50506001821b61067c565b5060208310610133831016604e8410600b84101617156127d1575081810a61067c565b6127de6000198484612713565b80600019048211156127f2576127f26123c9565b029392505050565b60006114f08383612756565b60006020828403121561281857600080fd5b81516114f081611f47565b600080600080600080600060e0888a03121561283e57600080fd5b875161284981611f47565b8097505060208801518060020b811461286157600080fd5b955061286f60408901612536565b945061287d60608901612536565b935061288b60808901612536565b925061289960a089016126e7565b91506128a760c089016123f2565b905092959891949750929550565b60006114f060ff841683612756565b6000602082840312156128d657600080fd5b6114f083836124bf565b60008060008060008060c087890312156128f957600080fd5b50508451602086015160408701516060880151608089015160a090990151939a929950909790965094509092509050565b6000825161293c818460208701612341565b919091019291505056fea2646970667358221220c0db290aa3ff0444962ca5a05c8739a0849dd60b7c036eac1d4adee6ed6af25e64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\x01\xF0W`\x005`\xE0\x1C\x80c\xA2\x10\xE43\x11a\x01\x0FW\x80c\xC7\xA0\xB6\x18\x11a\0\xA2W\x80c\xE7\x8Ds\xAD\x11a\0qW\x80c\xE7\x8Ds\xAD\x14a\x04\xC4W\x80c\xE8\xF3yc\x14a\x04\xD7W\x80c\xF3\x8E&j\x14a\x05\x0CW\x80c\xF7>Z\xAB\x14a\x05\x1FW`\0\x80\xFD[\x80c\xC7\xA0\xB6\x18\x14a\x04xW\x80c\xCAtS\xD4\x14a\x04\x8BW\x80c\xCC\xE1\xCDm\x14a\x04\x9EW\x80c\xE3c8\xDB\x14a\x04\xB1W`\0\x80\xFD[\x80c\xB3Yo\x07\x11a\0\xDEW\x80c\xB3Yo\x07\x14a\x04\x18W\x80c\xB4\xDC\xFCw\x14a\x04+W\x80c\xB4\xF8\xB0{\x14a\x04RW\x80c\xBC\xA7\xA4`\x14a\x04eW`\0\x80\xFD[\x80c\xA2\x10\xE43\x14a\x03\xA9W\x80c\xA7G\xB9;\x14a\x03\xD7W\x80c\xAC\xA2_\x9A\x14a\x03\xEAW\x80c\xB1\x1D\xE7\xE3\x14a\x03\xFDW`\0\x80\xFD[\x80cX\x86\xE7\xC1\x11a\x01\x87W\x80ck\x1B\x9B \x11a\x01VW\x80ck\x1B\x9B \x14a\x03TW\x80cuf\x95Q\x14a\x03{W\x80c}j\xF0y\x14a\x03\x8EW\x80c\x8A\x0C\xCFl\x14a\x03\xA1W`\0\x80\xFD[\x80cX\x86\xE7\xC1\x14a\x03\x06W\x80c]\xDF\xBC[\x14a\x03\x19W\x80c_j\x18\xDB\x14a\x03!W\x80ci\xC8\x12\xBA\x14a\x034W`\0\x80\xFD[\x80c*\xB0\xAA\xBB\x11a\x01\xC3W\x80c*\xB0\xAA\xBB\x14a\x02\xA4W\x80c2\x9E\xF6\xDF\x14a\x02\xB9W\x80cA\xC6J/\x14a\x02\xCCW\x80cSsC?\x14a\x02\xF3W`\0\x80\xFD[\x80c\x04\x01A\xE5\x14a\x01\xF5W\x80c\r}\xE3\x7F\x14a\x029W\x80c\x11x\x03\xE3\x14a\x02ZW\x80c\x1B\x11\xD0\xFF\x14a\x02\x81W[`\0\x80\xFD[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x02La\x02G6`\x04a\x1F\\V[a\x05FV[`@Q\x90\x81R` \x01a\x020V[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\x94a\x02\x8F6`\x04a\x1F\x95V[a\x06\x82V[`@Q\x90\x15\x15\x81R` \x01a\x020V[a\x02\xB7a\x02\xB26`\x04a \xB3V[a\x081V[\0[a\x02La\x02\xC76`\x04a!sV[a\x08\x88V[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02La\x03\x016`\x04a!\xCEV[a\t\xD7V[a\x02La\x03\x146`\x04a!\xCEV[a\nBV[a\x02L`\x02\x81V[a\x02La\x03/6`\x04a!\xEBV[a\x0B5V[a\x03Ga\x03B6`\x04a!\xCEV[a\r%V[`@Qa\x020\x91\x90a\"<V[a\x03ga\x03b6`\x04a\"\x88V[a\x0EQV[`@Qb\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x020V[a\x02La\x03\x896`\x04a!\xEBV[a\x0E\x8AV[a\x02La\x03\x9C6`\x04a!\xCEV[a\x0F\x9FV[a\x02L`d\x81V[a\x03\xBCa\x03\xB76`\x04a\"\xA1V[a\x10JV[`@\x80Qb\xFF\xFF\xFF\x90\x93\x16\x83R` \x83\x01\x91\x90\x91R\x01a\x020V[a\x02La\x03\xE56`\x04a!\xCEV[a\x12RV[a\x02La\x03\xF86`\x04a!\xCEV[a\x13\0V[a\x02\x1Cs\x11\x11\x11\x12T\xEE\xB2Tw\xB6\x8F\xB8^\xD9)\xF7:\x96\x05\x82\x81V[a\x02La\x04&6`\x04a!\xCEV[a\x13\x9BV[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xB7a\x04`6`\x04a\"\xF2V[a\x14\xF7V[a\x02\xB7a\x04s6`\x04a\"\xF2V[a\x16\x14V[a\x02\xB7a\x04\x866`\x04a\"\xF2V[a\x16\xB7V[a\x02La\x04\x996`\x04a!\xCEV[a\x17\x9AV[a\x02La\x04\xAC6`\x04a!\xEBV[a\x18AV[a\x02\xB7a\x04\xBF6`\x04a\"\xF2V[a\x19\x02V[a\x02\xB7a\x04\xD26`\x04a \xB3V[a\x19\xE0V[a\x04\xDFa\x1A2V[`@\x80Q\x96\x87R` \x87\x01\x95\x90\x95R\x93\x85\x01\x92\x90\x92R``\x84\x01R`\x80\x83\x01R`\xA0\x82\x01R`\xC0\x01a\x020V[a\x02La\x05\x1A6`\x04a!\xCEV[a\x1A\xDAV[a\x02\x1C\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x05\x99W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Q\x80\x91\x03\x90\xFD[`\0a\x05\xA4\x83a\x0F\x9FV[\x90P\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cB\xB0\xB7|0\x85\x84\x88\x88`@Q` \x01a\x06\0\x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R`\0`@Q\x86c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x061\x95\x94\x93\x92\x91\x90a#eV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x06KW`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x06_W=`\0\x80>=`\0\xFD[PPPPa\x06o\x84`\0\x19a\x16\x14V[a\x06x\x84a\nBV[\x91PP[\x92\x91PPV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x06\xFCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCaller must be lending pool\0\0\0\0\0`D\x82\x01R`d\x01a\x05\x90V[`\x01`\x01`\xA0\x1B\x03\x84\x160\x14a\x07TW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FInitiator must be this contract\0`D\x82\x01R`d\x01a\x05\x90V[`\0\x80a\x07c\x84\x86\x01\x86a\x1F\\V[\x91P\x91Pa\x07q\x81\x89a\x14\xF7V[a\x07}\x82`\0\x19a\x16\x14V[`\0a\x07\x89\x88\x8Aa#\xDFV[`@Qc\t^\xA7\xB3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R\x91\x92P\x90\x8B\x16\x90c\t^\xA7\xB3\x90`D\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x07\xFCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08 \x91\x90a$\x02V[P`\x01\x9A\x99PPPPPPPPPPV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x08yW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x08\x83\x82\x82a\x1B,V[PPPV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x08\xD2W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[\x83\x15a\tQW`@Qc#\xB8r\xDD`\xE0\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R`D\x81\x01\x85\x90R`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c#\xB8r\xDD\x90`d\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\t+W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\tO\x91\x90a$\x02V[P[`\0a\t\\\x87a\t\xD7V[\x11\x15a\toWa\to\x86a\x04\xBF\x88a\t\xD7V[`\0[\x83\x81\x10\x15a\t\xC3Wa\t\x93\x86`da\t\x89\x89a\x17\x9AV[a\x04\x86\x91\x90a$\x1DV[`\0a\t\x9E\x87a\t\xD7V[\x90Pa\t\xAC\x87\x89\x83\x87a\x0B5V[Pa\t\xBA\x88a\x04\xBF\x8Aa\t\xD7V[P`\x01\x01a\trV[Pa\t\xCD\x86a\x12RV[\x96\x95PPPPPPV[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\x1EW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06|\x91\x90a$0V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\n\x8CW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qcp\xA0\x821`\xE0\x1B\x81R0`\x04\x82\x01R`\0\x90`\x01`\x01`\xA0\x1B\x03\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\n\xD3W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xF7\x91\x90a$0V[\x90Pa\x0B-`\x01`\x01`\xA0\x1B\x03\x84\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1B\x99V[\x90P[\x91\x90PV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0B\x7FW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qc\t^\xA7\xB3`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x04\x83\x01R`$\x82\x01\x85\x90R\x86\x16\x90c\t^\xA7\xB3\x90`D\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x0B\xEEW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0C\x12\x91\x90a$\x02V[P`\0`@Q\x80a\x01\0\x01`@R\x80\x87`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x84b\xFF\xFF\xFF\x16\x81R` \x010`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01Ba\x01,a\x0Cg\x91\x90a#\xDFV[\x81R` \x01\x85\x81R` \x01`\x01\x81R` \x01`\0`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90P`\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16cAK\xF3\x89\x83`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0C\xD7\x91\x90a$IV[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x0C\xF6W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x1A\x91\x90a$0V[\x97\x96PPPPPPPV[`@Qc5\xEAju`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R``\x91`\0\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c5\xEAju\x90`$\x01a\x01\xE0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x92W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB6\x91\x90a%SV[`@\x80Q`\x02\x80\x82R``\x82\x01\x83R\x92\x93P\x91\x90` \x83\x01\x90\x806\x837\x01\x90PP\x91P\x80a\x01\0\x01Q\x82`\0\x81Q\x81\x10a\r\xF2Wa\r\xF2a&\x7FV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPP\x80a\x01@\x01Q\x82`\x01\x81Q\x81\x10a\x0E+Wa\x0E+a&\x7FV[` \x02` \x01\x01\x90`\x01`\x01`\xA0\x1B\x03\x16\x90\x81`\x01`\x01`\xA0\x1B\x03\x16\x81RPPP\x91\x90PV[`\0\x81\x81T\x81\x10a\x0EaW`\0\x80\xFD[\x90`\0R` `\0 \x90`\n\x91\x82\x82\x04\x01\x91\x90\x06`\x03\x02\x91PT\x90a\x01\0\n\x90\x04b\xFF\xFF\xFF\x16\x81V[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x0E\xD4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`\0\x80a\x0E\xDFa\x1A2V[P\x94PPP\x92PP`\0[a'\x10\x83\x11\x80\x15a\x0E\xFAWP\x85\x81\x10[\x15a\x0FnWa\x0F/\x88`d\x84a\x0F\x0F\x8Ca\x12RV[a\x0F\x1B\x90a'\x10a&\x95V[a\x0F%\x91\x90a&\xACV[a\x04s\x91\x90a$\x1DV[a\x0FC\x88\x88a\x0F=\x8Ba\t\xD7V[\x88a\x0B5V[Pa\x0FQ\x87a\x04`\x89a\t\xD7V[a\x0FZ\x87a\x0F\x9FV[\x92P\x80a\x0Ff\x81a&\xCEV[\x91PPa\x0E\xEAV[a\x0Fw\x87a\x0F\x9FV[`\0\x03a\x0F\x8AWa\x0F\x8A\x88`\0\x19a\x16\x14V[a\x0F\x93\x88a\nBV[\x98\x97PPPPPPPPV[`\0\x80a\x0F\xAAa\x1A2V[PPPP\x91PP`\0\x83`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F\xF1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\x15\x91\x90a&\xF8V[`\xFF\x16\x90Pa\x10#\x84a\x13\x9BV[a\x10.\x82`\na'\xFAV[a\x108\x90\x84a&\x95V[a\x10B\x91\x90a&\xACV[\x94\x93PPPPV[`\0\x80`\0[`\0T\x81\x10\x15a\x12HW`\0\x87`\x01`\x01`\xA0\x1B\x03\x16c\x16\x98\xEE\x82\x88\x88`\0\x86\x81T\x81\x10a\x10\x80Wa\x10\x80a&\x7FV[`\0\x91\x82R` \x90\x91 `\n\x80\x83\x04\x90\x91\x01T`@Q`\xE0\x87\x90\x1B`\x01`\x01`\xE0\x1B\x03\x19\x16\x81R`\x01`\x01`\xA0\x1B\x03\x95\x86\x16`\x04\x82\x01R\x93\x90\x94\x16`$\x84\x01R\x90\x06`\x03\x02a\x01\0\n\x90\x91\x04b\xFF\xFF\xFF\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x10\xF6W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\x1A\x91\x90a(\x06V[\x90P`\x01`\x01`\xA0\x1B\x03\x81\x16a\x110WPa\x12@V[`\0\x81`\x01`\x01`\xA0\x1B\x03\x16c8P\xC7\xBD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\xE0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11pW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\x94\x91\x90a(#V[PPPPPP\x90P`\0`\xC0\x82`\x01`\x01`\xA0\x1B\x03\x16\x83`\x01`\x01`\xA0\x1B\x03\x16a\x11\xBE\x91\x90a&\x95V[a\x11\xD0\x90g\r\xE0\xB6\xB3\xA7d\0\0a&\x95V[\x90\x1C\x90P`\0g\r\xE0\xB6\xB3\xA7d\0\0a\x11\xE9\x83\x8Aa&\x95V[a\x11\xF3\x91\x90a&\xACV[\x90P\x85\x81\x11\x15a\x12;W`\0\x85\x81T\x81\x10a\x12\x10Wa\x12\x10a&\x7FV[\x90`\0R` `\0 \x90`\n\x91\x82\x82\x04\x01\x91\x90\x06`\x03\x02\x90T\x90a\x01\0\n\x90\x04b\xFF\xFF\xFF\x16\x96P\x80\x95P[PPPP[`\x01\x01a\x10PV[P\x94P\x94\x92PPPV[`\0\x80a\x12]a\x1A2V[PPP\x92PPP`\0a\x12o\x84a\x13\x9BV[\x90P`\0\x84`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x12\xB1W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x12\xD5\x91\x90a&\xF8V[\x90P\x81a\x12\xE3\x82`\na(\xB5V[a\x12\xED\x90\x85a&\x95V[a\x12\xF7\x91\x90a&\xACV[\x95\x94PPPPPV[`@Qc\xC4K\x11\xF7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x81\x16`\x04\x83\x01R`\0\x91\x82\x91\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xC4K\x11\xF7\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13kW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x13\x8F\x91\x90a(\xC4V[Qa\xFF\xFF\x16\x93\x92PPPV[`\0\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16c\x05B\x97\\`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x13\xFCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14 \x91\x90a(\x06V[\x90P\x80`\x01`\x01`\xA0\x1B\x03\x16c\xFC\xA5\x13\xA8`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x14`W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\x84\x91\x90a(\x06V[`@Qc\xB3Yo\x07`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x81\x16`\x04\x83\x01R\x91\x90\x91\x16\x90c\xB3Yo\x07\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x14\xCCW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14\xF0\x91\x90a$0V[\x93\x92PPPV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x15?W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x15s`\x01`\x01`\xA0\x1B\x03\x83\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1B\xF8V[`@QcW:\xDE\x81`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cW:\xDE\x81\x90`\x84\x01[` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x15\xF0W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\x83\x91\x90a$0V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x16\\W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qc\x1AL\xA3{`\xE2\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90ci2\x8D\xEC\x90`d\x01a\x15\xD1V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x16\xFFW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qc\xA4\x15\xBC\xAD`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R`\x02`D\x83\x01R`\0`d\x83\x01R0`\x84\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xA4\x15\xBC\xAD\x90`\xA4\x01[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a\x17~W`\0\x80\xFD[PZ\xF1\x15\x80\x15a\x17\x92W=`\0\x80>=`\0\xFD[PPPPPPV[`\0\x80a\x17\xA5a\x1A2V[PPP\x92PPP`\0a\x17\xB7\x84a\x13\x9BV[\x90P`\0\x84`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x17\xF9W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\x1D\x91\x90a&\xF8V[\x90P`\0\x82a\x18-\x83`\na(\xB5V[a\x187\x90\x86a&\x95V[a\t\xCD\x91\x90a&\xACV[`\x003`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x18\x8BW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[`@Qcp\xA0\x821`\xE0\x1B\x81R3`\x04\x82\x01Ra\x12\xF7\x90\x86\x90\x86\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18\xD7W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18\xFB\x91\x90a$0V[\x86\x86a\x08\x88V[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x19JW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x19~`\x01`\x01`\xA0\x1B\x03\x83\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1B\xF8V[`@Qc\xE8\xED\xA9\xDF`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R`$\x82\x01\x83\x90R0`D\x83\x01R`\0`d\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xE8\xED\xA9\xDF\x90`\x84\x01a\x17dV[3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x1A(W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x05\x90\x90a#\x1EV[a\x08\x83\x82\x82a\x1C\x88V[`@Qc/\xE4\xA1_`\xE2\x1B\x81R0`\x04\x82\x01R`\0\x90\x81\x90\x81\x90\x81\x90\x81\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xBF\x92\x85|\x90`$\x01`\xC0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1A\xA3W=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1A\xC7\x91\x90a(\xE0V[\x94\x9B\x93\x9AP\x91\x98P\x96P\x94P\x90\x92P\x90PV[`\0\x80a\x1A\xE5a\x1A2V[PPPPP\x90P`\0\x83`\x01`\x01`\xA0\x1B\x03\x16c1<\xE5g`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F\xF1W=`\0\x80>=`\0\xFD[```\0\x80\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x1BI\x91\x90a)*V[`\0`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80`\0\x81\x14a\x1B\x84W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1B\x89V[``\x91P[P\x91P\x91Pa\x12\xF7\x85\x83\x83a\x1C\x96V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`D\x82\x01\x83\x90Ra\x08\x83\x91\x85\x91\x82\x16\x90c\xA9\x05\x9C\xBB\x90`d\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x91P`\xE0\x1B` \x82\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x83\x81\x83\x16\x17\x83RPPPPa\x1C\xF2V[`@Qcn\xB1v\x9F`\xE1\x1B\x81R0`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`$\x83\x01R`\0\x91\x90\x85\x16\x90c\xDDb\xED>\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1CHW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1Cl\x91\x90a$0V[\x90Pa\x1C\x82\x84\x84a\x1C}\x85\x85a#\xDFV[a\x1DUV[PPPPV[``a\x14\xF0\x83\x83`\0a\x1D\xE5V[``\x82a\x1C\xABWa\x1C\xA6\x82a\x1ExV[a\x14\xF0V[\x81Q\x15\x80\x15a\x1C\xC2WP`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15[\x15a\x1C\xEBW`@Qc\x99\x96\xB3\x15`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R`$\x01a\x05\x90V[P\x92\x91PPV[`\0a\x1D\x07`\x01`\x01`\xA0\x1B\x03\x84\x16\x83a\x1C\x88V[\x90P\x80Q`\0\x14\x15\x80\x15a\x1D,WP\x80\x80` \x01\x90Q\x81\x01\x90a\x1D*\x91\x90a$\x02V[\x15[\x15a\x08\x83W`@QcRt\xAF\xE7`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04\x82\x01R`$\x01a\x05\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x82\x01R`D\x80\x82\x01\x84\x90R\x82Q\x80\x83\x03\x90\x91\x01\x81R`d\x90\x91\x01\x90\x91R` \x81\x01\x80Q`\x01`\x01`\xE0\x1B\x03\x16c\t^\xA7\xB3`\xE0\x1B\x17\x90Ra\x1D\xA6\x84\x82a\x1E\xA4V[a\x1C\x82W`@Q`\x01`\x01`\xA0\x1B\x03\x84\x81\x16`$\x83\x01R`\0`D\x83\x01Ra\x1D\xDB\x91\x86\x91\x82\x16\x90c\t^\xA7\xB3\x90`d\x01a\x1B\xC6V[a\x1C\x82\x84\x82a\x1C\xF2V[``\x81G\x10\x15a\x1E\nW`@Qc\xCDx`Y`\xE0\x1B\x81R0`\x04\x82\x01R`$\x01a\x05\x90V[`\0\x80\x85`\x01`\x01`\xA0\x1B\x03\x16\x84\x86`@Qa\x1E&\x91\x90a)*V[`\0`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80`\0\x81\x14a\x1EcW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1EhV[``\x91P[P\x91P\x91Pa\t\xCD\x86\x83\x83a\x1C\x96V[\x80Q\x15a\x1E\x88W\x80Q\x80\x82` \x01\xFD[`@Qc\n\x12\xF5!`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PV[`\0\x80`\0\x84`\x01`\x01`\xA0\x1B\x03\x16\x84`@Qa\x1E\xC1\x91\x90a)*V[`\0`@Q\x80\x83\x03\x81`\0\x86Z\xF1\x91PP=\x80`\0\x81\x14a\x1E\xFEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=`\0` \x84\x01>a\x1F\x03V[``\x91P[P\x91P\x91P\x81\x80\x15a\x1F-WP\x80Q\x15\x80a\x1F-WP\x80\x80` \x01\x90Q\x81\x01\x90a\x1F-\x91\x90a$\x02V[\x80\x15a\x12\xF7WPPPPP`\x01`\x01`\xA0\x1B\x03\x16;\x15\x15\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x1E\xA1W`\0\x80\xFD[`\0\x80`@\x83\x85\x03\x12\x15a\x1FoW`\0\x80\xFD[\x825a\x1Fz\x81a\x1FGV[\x91P` \x83\x015a\x1F\x8A\x81a\x1FGV[\x80\x91PP\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\xA0\x87\x89\x03\x12\x15a\x1F\xAEW`\0\x80\xFD[\x865a\x1F\xB9\x81a\x1FGV[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015a\x1F\xD7\x81a\x1FGV[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1F\xF3W`\0\x80\xFD[\x87\x01`\x1F\x81\x01\x89\x13a \x04W`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \x1BW`\0\x80\xFD[\x89` \x82\x84\x01\x01\x11\x15a -W`\0\x80\xFD[` \x82\x01\x93P\x80\x92PPP\x92\x95P\x92\x95P\x92\x95V[cNH{q`\xE0\x1B`\0R`A`\x04R`$`\0\xFD[`@Qa\x01\xE0\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a |Wa |a BV[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a \xABWa \xABa BV[`@R\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a \xC6W`\0\x80\xFD[\x825a \xD1\x81a\x1FGV[\x91P` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \xEDW`\0\x80\xFD[\x83\x01`\x1F\x81\x01\x85\x13a \xFEW`\0\x80\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\x18Wa!\x18a BV[a!+`\x1F\x82\x01`\x1F\x19\x16` \x01a \x82V[\x81\x81R\x86` \x83\x85\x01\x01\x11\x15a!@W`\0\x80\xFD[\x81` \x84\x01` \x83\x017`\0` \x83\x83\x01\x01R\x80\x93PPPP\x92P\x92\x90PV[\x805b\xFF\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[`\0\x80`\0\x80`\0`\xA0\x86\x88\x03\x12\x15a!\x8BW`\0\x80\xFD[\x855a!\x96\x81a\x1FGV[\x94P` \x86\x015a!\xA6\x81a\x1FGV[\x93P`@\x86\x015\x92P``\x86\x015\x91Pa!\xC2`\x80\x87\x01a!`V[\x90P\x92\x95P\x92\x95\x90\x93PV[`\0` \x82\x84\x03\x12\x15a!\xE0W`\0\x80\xFD[\x815a\x14\xF0\x81a\x1FGV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\"\x01W`\0\x80\xFD[\x845a\"\x0C\x81a\x1FGV[\x93P` \x85\x015a\"\x1C\x81a\x1FGV[\x92P`@\x85\x015\x91Pa\"1``\x86\x01a!`V[\x90P\x92\x95\x91\x94P\x92PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R`\0\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\"}W\x83Q`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\"VV[P\x90\x95\x94PPPPPV[`\0` \x82\x84\x03\x12\x15a\"\x9AW`\0\x80\xFD[P5\x91\x90PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15a\"\xB7W`\0\x80\xFD[\x845a\"\xC2\x81a\x1FGV[\x93P` \x85\x015a\"\xD2\x81a\x1FGV[\x92P`@\x85\x015a\"\xE2\x81a\x1FGV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[`\0\x80`@\x83\x85\x03\x12\x15a#\x05W`\0\x80\xFD[\x825a#\x10\x81a\x1FGV[\x94` \x93\x90\x93\x015\x93PPPV[` \x80\x82R`\t\x90\x82\x01Rh7\xB76<\xA7\xBB\xB72\xB9`\xB9\x1B`@\x82\x01R``\x01\x90V[`\0[\x83\x81\x10\x15a#\\W\x81\x81\x01Q\x83\x82\x01R` \x01a#DV[PP`\0\x91\x01RV[`\x01\x80`\xA0\x1B\x03\x86\x16\x81R`\x01\x80`\xA0\x1B\x03\x85\x16` \x82\x01R\x83`@\x82\x01R`\xA0``\x82\x01R`\0\x83Q\x80`\xA0\x84\x01Ra#\xA6\x81`\xC0\x85\x01` \x88\x01a#AV[a\xFF\xFF\x93\x90\x93\x16`\x80\x83\x01RP`\x1F\x91\x90\x91\x01`\x1F\x19\x16\x01`\xC0\x01\x94\x93PPPPV[cNH{q`\xE0\x1B`\0R`\x11`\x04R`$`\0\xFD[\x80\x82\x01\x80\x82\x11\x15a\x06|Wa\x06|a#\xC9V[\x80Q\x80\x15\x15\x81\x14a\x0B0W`\0\x80\xFD[`\0` \x82\x84\x03\x12\x15a$\x14W`\0\x80\xFD[a\x14\xF0\x82a#\xF2V[\x81\x81\x03\x81\x81\x11\x15a\x06|Wa\x06|a#\xC9V[`\0` \x82\x84\x03\x12\x15a$BW`\0\x80\xFD[PQ\x91\x90PV[\x81Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R` \x80\x84\x01Q\x82\x16\x90\x83\x01R`@\x80\x84\x01Qb\xFF\xFF\xFF\x16\x90\x83\x01R``\x80\x84\x01Q\x91\x82\x16\x90\x83\x01Ra\x01\0\x82\x01\x90P`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Q`\xC0\x83\x01R`\xE0\x83\x01Qa\x1C\xEB`\xE0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[`\0` \x82\x84\x03\x12\x15a$\xD1W`\0\x80\xFD[`@Q` \x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a$\xF4Wa$\xF4a BV[`@R\x91Q\x82RP\x91\x90PV[\x80Qo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[\x80Qd\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[\x80Qa\xFF\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[\x80Qa\x0B0\x81a\x1FGV[`\0a\x01\xE0\x82\x84\x03\x12\x80\x15a%gW`\0\x80\xFD[Pa%pa XV[a%z\x84\x84a$\xBFV[\x81Ra%\x88` \x84\x01a%\x01V[` \x82\x01Ra%\x99`@\x84\x01a%\x01V[`@\x82\x01Ra%\xAA``\x84\x01a%\x01V[``\x82\x01Ra%\xBB`\x80\x84\x01a%\x01V[`\x80\x82\x01Ra%\xCC`\xA0\x84\x01a%\x01V[`\xA0\x82\x01Ra%\xDD`\xC0\x84\x01a%!V[`\xC0\x82\x01Ra%\xEE`\xE0\x84\x01a%6V[`\xE0\x82\x01Ra&\0a\x01\0\x84\x01a%HV[a\x01\0\x82\x01Ra&\x13a\x01 \x84\x01a%HV[a\x01 \x82\x01Ra&&a\x01@\x84\x01a%HV[a\x01@\x82\x01Ra&9a\x01`\x84\x01a%HV[a\x01`\x82\x01Ra&La\x01\x80\x84\x01a%\x01V[a\x01\x80\x82\x01Ra&_a\x01\xA0\x84\x01a%\x01V[a\x01\xA0\x82\x01Ra&ra\x01\xC0\x84\x01a%\x01V[a\x01\xC0\x82\x01R\x93\x92PPPV[cNH{q`\xE0\x1B`\0R`2`\x04R`$`\0\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x06|Wa\x06|a#\xC9V[`\0\x82a&\xC9WcNH{q`\xE0\x1B`\0R`\x12`\x04R`$`\0\xFD[P\x04\x90V[`\0`\x01\x82\x01a&\xE0Wa&\xE0a#\xC9V[P`\x01\x01\x90V[\x80Q`\xFF\x81\x16\x81\x14a\x0B0W`\0\x80\xFD[`\0` \x82\x84\x03\x12\x15a'\nW`\0\x80\xFD[a\x14\xF0\x82a&\xE7V[`\x01\x81[`\x01\x84\x11\x15a'NW\x80\x85\x04\x81\x11\x15a'2Wa'2a#\xC9V[`\x01\x84\x16\x15a'@W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a'\x17V[\x93P\x93\x91PPV[`\0\x82a'eWP`\x01a\x06|V[\x81a'rWP`\0a\x06|V[\x81`\x01\x81\x14a'\x88W`\x02\x81\x14a'\x92Wa'\xAEV[`\x01\x91PPa\x06|V[`\xFF\x84\x11\x15a'\xA3Wa'\xA3a#\xC9V[PP`\x01\x82\x1Ba\x06|V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a'\xD1WP\x81\x81\na\x06|V[a'\xDE`\0\x19\x84\x84a'\x13V[\x80`\0\x19\x04\x82\x11\x15a'\xF2Wa'\xF2a#\xC9V[\x02\x93\x92PPPV[`\0a\x14\xF0\x83\x83a'VV[`\0` \x82\x84\x03\x12\x15a(\x18W`\0\x80\xFD[\x81Qa\x14\xF0\x81a\x1FGV[`\0\x80`\0\x80`\0\x80`\0`\xE0\x88\x8A\x03\x12\x15a(>W`\0\x80\xFD[\x87Qa(I\x81a\x1FGV[\x80\x97PP` \x88\x01Q\x80`\x02\x0B\x81\x14a(aW`\0\x80\xFD[\x95Pa(o`@\x89\x01a%6V[\x94Pa(}``\x89\x01a%6V[\x93Pa(\x8B`\x80\x89\x01a%6V[\x92Pa(\x99`\xA0\x89\x01a&\xE7V[\x91Pa(\xA7`\xC0\x89\x01a#\xF2V[\x90P\x92\x95\x98\x91\x94\x97P\x92\x95PV[`\0a\x14\xF0`\xFF\x84\x16\x83a'VV[`\0` \x82\x84\x03\x12\x15a(\xD6W`\0\x80\xFD[a\x14\xF0\x83\x83a$\xBFV[`\0\x80`\0\x80`\0\x80`\xC0\x87\x89\x03\x12\x15a(\xF9W`\0\x80\xFD[PP\x84Q` \x86\x01Q`@\x87\x01Q``\x88\x01Q`\x80\x89\x01Q`\xA0\x90\x99\x01Q\x93\x9A\x92\x99P\x90\x97\x90\x96P\x94P\x90\x92P\x90PV[`\0\x82Qa)<\x81\x84` \x87\x01a#AV[\x91\x90\x91\x01\x92\x91PPV\xFE\xA2dipfsX\"\x12 \xC0\xDB)\n\xA3\xFF\x04D\x96,\xA5\xA0\\\x879\xA0\x84\x9D\xD6\x0B|\x03n\xAC\x1DJ\xDE\xE6\xEDj\xF2^dsolcC\0\x08\x1A\x003",
    );
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `AddressInsufficientBalance(address)` and selector `0xcd786059`.
```solidity
error AddressInsufficientBalance(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AddressInsufficientBalance {
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressInsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: AddressInsufficientBalance) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AddressInsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressInsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressInsufficientBalance(address)";
            const SELECTOR: [u8; 4] = [205u8, 120u8, 96u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `FailedInnerCall()` and selector `0x1425ea42`.
```solidity
error FailedInnerCall();
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct FailedInnerCall {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedInnerCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedInnerCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedInnerCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedInnerCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedInnerCall()";
            const SELECTOR: [u8; 4] = [20u8, 37u8, 234u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address owner, address lendingPool, address wethAddress, address uniswapV3Router);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub owner: alloy::sol_types::private::Address,
        pub lendingPool: alloy::sol_types::private::Address,
        pub wethAddress: alloy::sol_types::private::Address,
        pub uniswapV3Router: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.owner,
                        value.lendingPool,
                        value.wethAddress,
                        value.uniswapV3Router,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        lendingPool: tuple.1,
                        wethAddress: tuple.2,
                        uniswapV3Router: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lendingPool,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.wethAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.uniswapV3Router,
                    ),
                )
            }
        }
    };
    /**Function with signature `AGGREGATION_ROUTER_V5()` and selector `0xb11de7e3`.
```solidity
function AGGREGATION_ROUTER_V5() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AGGREGATION_ROUTER_V5Call {}
    ///Container type for the return parameters of the [`AGGREGATION_ROUTER_V5()`](AGGREGATION_ROUTER_V5Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AGGREGATION_ROUTER_V5Return {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AGGREGATION_ROUTER_V5Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: AGGREGATION_ROUTER_V5Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AGGREGATION_ROUTER_V5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AGGREGATION_ROUTER_V5Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: AGGREGATION_ROUTER_V5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AGGREGATION_ROUTER_V5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for AGGREGATION_ROUTER_V5Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = AGGREGATION_ROUTER_V5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AGGREGATION_ROUTER_V5()";
            const SELECTOR: [u8; 4] = [177u8, 29u8, 231u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `FEE_TIERS(uint256)` and selector `0x6b1b9b20`.
```solidity
function FEE_TIERS(uint256) external view returns (uint24);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct FEE_TIERSCall {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`FEE_TIERS(uint256)`](FEE_TIERSCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct FEE_TIERSReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U24,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<FEE_TIERSCall> for UnderlyingRustTuple<'_> {
                fn from(value: FEE_TIERSCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for FEE_TIERSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<FEE_TIERSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: FEE_TIERSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for FEE_TIERSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for FEE_TIERSCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = FEE_TIERSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FEE_TIERS(uint256)";
            const SELECTOR: [u8; 4] = [107u8, 27u8, 155u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LENDING_POOL()` and selector `0xb4dcfc77`.
```solidity
function LENDING_POOL() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct LENDING_POOLCall {}
    ///Container type for the return parameters of the [`LENDING_POOL()`](LENDING_POOLCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct LENDING_POOLReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LENDING_POOLCall> for UnderlyingRustTuple<'_> {
                fn from(value: LENDING_POOLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LENDING_POOLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LENDING_POOLReturn> for UnderlyingRustTuple<'_> {
                fn from(value: LENDING_POOLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LENDING_POOLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LENDING_POOLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LENDING_POOLReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LENDING_POOL()";
            const SELECTOR: [u8; 4] = [180u8, 220u8, 252u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `OWNER()` and selector `0x117803e3`.
```solidity
function OWNER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OWNERCall {}
    ///Container type for the return parameters of the [`OWNER()`](OWNERCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OWNERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OWNERCall> for UnderlyingRustTuple<'_> {
                fn from(value: OWNERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OWNERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OWNERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OWNERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OWNERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OWNERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = OWNERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OWNER()";
            const SELECTOR: [u8; 4] = [17u8, 120u8, 3u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SAFE_BUFFER()` and selector `0x8a0ccf6c`.
```solidity
function SAFE_BUFFER() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SAFE_BUFFERCall {}
    ///Container type for the return parameters of the [`SAFE_BUFFER()`](SAFE_BUFFERCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SAFE_BUFFERReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SAFE_BUFFERCall> for UnderlyingRustTuple<'_> {
                fn from(value: SAFE_BUFFERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SAFE_BUFFERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SAFE_BUFFERReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SAFE_BUFFERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SAFE_BUFFERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SAFE_BUFFERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SAFE_BUFFERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SAFE_BUFFER()";
            const SELECTOR: [u8; 4] = [138u8, 12u8, 207u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `UNISWAP_V3_FACTORY()` and selector `0xf73e5aab`.
```solidity
function UNISWAP_V3_FACTORY() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct UNISWAP_V3_FACTORYCall {}
    ///Container type for the return parameters of the [`UNISWAP_V3_FACTORY()`](UNISWAP_V3_FACTORYCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct UNISWAP_V3_FACTORYReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UNISWAP_V3_FACTORYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UNISWAP_V3_FACTORYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UNISWAP_V3_FACTORYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UNISWAP_V3_FACTORYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UNISWAP_V3_FACTORYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UNISWAP_V3_FACTORYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UNISWAP_V3_FACTORYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UNISWAP_V3_FACTORYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UNISWAP_V3_FACTORY()";
            const SELECTOR: [u8; 4] = [247u8, 62u8, 90u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `UNISWAP_V3_ROUTER()` and selector `0x41c64a2f`.
```solidity
function UNISWAP_V3_ROUTER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct UNISWAP_V3_ROUTERCall {}
    ///Container type for the return parameters of the [`UNISWAP_V3_ROUTER()`](UNISWAP_V3_ROUTERCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct UNISWAP_V3_ROUTERReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UNISWAP_V3_ROUTERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UNISWAP_V3_ROUTERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UNISWAP_V3_ROUTERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UNISWAP_V3_ROUTERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UNISWAP_V3_ROUTERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UNISWAP_V3_ROUTERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UNISWAP_V3_ROUTERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UNISWAP_V3_ROUTERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UNISWAP_V3_ROUTER()";
            const SELECTOR: [u8; 4] = [65u8, 198u8, 74u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `USE_VARIABLE_DEBT()` and selector `0x5ddfbc5b`.
```solidity
function USE_VARIABLE_DEBT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct USE_VARIABLE_DEBTCall {}
    ///Container type for the return parameters of the [`USE_VARIABLE_DEBT()`](USE_VARIABLE_DEBTCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct USE_VARIABLE_DEBTReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USE_VARIABLE_DEBTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: USE_VARIABLE_DEBTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for USE_VARIABLE_DEBTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USE_VARIABLE_DEBTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: USE_VARIABLE_DEBTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for USE_VARIABLE_DEBTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for USE_VARIABLE_DEBTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = USE_VARIABLE_DEBTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "USE_VARIABLE_DEBT()";
            const SELECTOR: [u8; 4] = [93u8, 223u8, 188u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `WETH_ADDRESS()` and selector `0x040141e5`.
```solidity
function WETH_ADDRESS() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct WETH_ADDRESSCall {}
    ///Container type for the return parameters of the [`WETH_ADDRESS()`](WETH_ADDRESSCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct WETH_ADDRESSReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<WETH_ADDRESSCall> for UnderlyingRustTuple<'_> {
                fn from(value: WETH_ADDRESSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for WETH_ADDRESSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<WETH_ADDRESSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: WETH_ADDRESSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for WETH_ADDRESSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for WETH_ADDRESSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = WETH_ADDRESSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WETH_ADDRESS()";
            const SELECTOR: [u8; 4] = [4u8, 1u8, 65u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_borrow(address,uint256)` and selector `0xc7a0b618`.
```solidity
function _borrow(address asset, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _borrowCall {
        pub asset: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`_borrow(address,uint256)`](_borrowCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _borrowReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_borrowCall> for UnderlyingRustTuple<'_> {
                fn from(value: _borrowCall) -> Self {
                    (value.asset, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _borrowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_borrowReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _borrowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _borrowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _borrowCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _borrowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_borrow(address,uint256)";
            const SELECTOR: [u8; 4] = [199u8, 160u8, 182u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_redeemSupply(address,uint256)` and selector `0xbca7a460`.
```solidity
function _redeemSupply(address asset, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _redeemSupplyCall {
        pub asset: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`_redeemSupply(address,uint256)`](_redeemSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _redeemSupplyReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_redeemSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: _redeemSupplyCall) -> Self {
                    (value.asset, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _redeemSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_redeemSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _redeemSupplyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _redeemSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _redeemSupplyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _redeemSupplyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_redeemSupply(address,uint256)";
            const SELECTOR: [u8; 4] = [188u8, 167u8, 164u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_repayBorrow(address,uint256)` and selector `0xb4f8b07b`.
```solidity
function _repayBorrow(address asset, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _repayBorrowCall {
        pub asset: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`_repayBorrow(address,uint256)`](_repayBorrowCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _repayBorrowReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_repayBorrowCall> for UnderlyingRustTuple<'_> {
                fn from(value: _repayBorrowCall) -> Self {
                    (value.asset, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _repayBorrowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_repayBorrowReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _repayBorrowReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _repayBorrowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _repayBorrowCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _repayBorrowReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_repayBorrow(address,uint256)";
            const SELECTOR: [u8; 4] = [180u8, 248u8, 176u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_supply(address,uint256)` and selector `0xe36338db`.
```solidity
function _supply(address asset, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _supplyCall {
        pub asset: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`_supply(address,uint256)`](_supplyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _supplyReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_supplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: _supplyCall) -> Self {
                    (value.asset, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _supplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_supplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: _supplyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for _supplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _supplyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _supplyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_supply(address,uint256)";
            const SELECTOR: [u8; 4] = [227u8, 99u8, 56u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `_withdrawToOwner(address)` and selector `0x5886e7c1`.
```solidity
function _withdrawToOwner(address asset) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _withdrawToOwnerCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`_withdrawToOwner(address)`](_withdrawToOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct _withdrawToOwnerReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_withdrawToOwnerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: _withdrawToOwnerCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _withdrawToOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<_withdrawToOwnerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: _withdrawToOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for _withdrawToOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for _withdrawToOwnerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = _withdrawToOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "_withdrawToOwner(address)";
            const SELECTOR: [u8; 4] = [88u8, 134u8, 231u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emergencyFunctionCall(address,bytes)` and selector `0xe78d73ad`.
```solidity
function emergencyFunctionCall(address target, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionCallCall {
        pub target: alloy::sol_types::private::Address,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`emergencyFunctionCall(address,bytes)`](emergencyFunctionCallCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionCallReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionCallCall) -> Self {
                    (value.target, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        target: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emergencyFunctionCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emergencyFunctionCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emergencyFunctionCall(address,bytes)";
            const SELECTOR: [u8; 4] = [231u8, 141u8, 115u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emergencyFunctionDelegateCall(address,bytes)` and selector `0x2ab0aabb`.
```solidity
function emergencyFunctionDelegateCall(address target, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionDelegateCallCall {
        pub target: alloy::sol_types::private::Address,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`emergencyFunctionDelegateCall(address,bytes)`](emergencyFunctionDelegateCallCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct emergencyFunctionDelegateCallReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionDelegateCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionDelegateCallCall) -> Self {
                    (value.target, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionDelegateCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        target: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emergencyFunctionDelegateCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emergencyFunctionDelegateCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emergencyFunctionDelegateCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emergencyFunctionDelegateCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emergencyFunctionDelegateCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emergencyFunctionDelegateCall(address,bytes)";
            const SELECTOR: [u8; 4] = [42u8, 176u8, 170u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `executeOperation(address,uint256,uint256,address,bytes)` and selector `0x1b11d0ff`.
```solidity
function executeOperation(address asset, uint256 amount, uint256 premium, address initiator, bytes memory params) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct executeOperationCall {
        pub asset: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        pub premium: alloy::sol_types::private::primitives::aliases::U256,
        pub initiator: alloy::sol_types::private::Address,
        pub params: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`executeOperation(address,uint256,uint256,address,bytes)`](executeOperationCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct executeOperationReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeOperationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeOperationCall) -> Self {
                    (
                        value.asset,
                        value.amount,
                        value.premium,
                        value.initiator,
                        value.params,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeOperationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        asset: tuple.0,
                        amount: tuple.1,
                        premium: tuple.2,
                        initiator: tuple.3,
                        params: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeOperationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeOperationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeOperationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeOperationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeOperationReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeOperation(address,uint256,uint256,address,bytes)";
            const SELECTOR: [u8; 4] = [27u8, 17u8, 208u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.premium),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initiator,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.params,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exitPosition(address,address,uint256,uint24)` and selector `0x75669551`.
```solidity
function exitPosition(address supplyAsset, address borrowAsset, uint256 maxIterations, uint24 feeTier) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exitPositionCall {
        pub supplyAsset: alloy::sol_types::private::Address,
        pub borrowAsset: alloy::sol_types::private::Address,
        pub maxIterations: alloy::sol_types::private::primitives::aliases::U256,
        pub feeTier: alloy::sol_types::private::primitives::aliases::U24,
    }
    ///Container type for the return parameters of the [`exitPosition(address,address,uint256,uint24)`](exitPositionCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exitPositionReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exitPositionCall> for UnderlyingRustTuple<'_> {
                fn from(value: exitPositionCall) -> Self {
                    (
                        value.supplyAsset,
                        value.borrowAsset,
                        value.maxIterations,
                        value.feeTier,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exitPositionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        supplyAsset: tuple.0,
                        borrowAsset: tuple.1,
                        maxIterations: tuple.2,
                        feeTier: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exitPositionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: exitPositionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exitPositionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exitPositionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exitPositionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exitPosition(address,address,uint256,uint24)";
            const SELECTOR: [u8; 4] = [117u8, 102u8, 149u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.supplyAsset,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.borrowAsset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxIterations),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeTier),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exitPositionWithFlashLoan(address,address)` and selector `0x0d7de37f`.
```solidity
function exitPositionWithFlashLoan(address supplyAsset, address borrowAsset) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exitPositionWithFlashLoanCall {
        pub supplyAsset: alloy::sol_types::private::Address,
        pub borrowAsset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`exitPositionWithFlashLoan(address,address)`](exitPositionWithFlashLoanCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exitPositionWithFlashLoanReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exitPositionWithFlashLoanCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: exitPositionWithFlashLoanCall) -> Self {
                    (value.supplyAsset, value.borrowAsset)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for exitPositionWithFlashLoanCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        supplyAsset: tuple.0,
                        borrowAsset: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exitPositionWithFlashLoanReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: exitPositionWithFlashLoanReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for exitPositionWithFlashLoanReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exitPositionWithFlashLoanCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exitPositionWithFlashLoanReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exitPositionWithFlashLoan(address,address)";
            const SELECTOR: [u8; 4] = [13u8, 125u8, 227u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.supplyAsset,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.borrowAsset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAssetBalance(address)` and selector `0x5373433f`.
```solidity
function getAssetBalance(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetBalanceCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAssetBalance(address)`](getAssetBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetBalanceReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetBalanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetBalanceCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAssetBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAssetBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAssetBalanceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAssetBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAssetBalance(address)";
            const SELECTOR: [u8; 4] = [83u8, 115u8, 67u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAssetPrice(address)` and selector `0xb3596f07`.
```solidity
function getAssetPrice(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetPriceCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAssetPrice(address)`](getAssetPriceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAssetPriceReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetPriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetPriceCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetPriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetPriceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetPriceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetPriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAssetPriceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAssetPriceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAssetPrice(address)";
            const SELECTOR: [u8; 4] = [179u8, 89u8, 111u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAvailableBorrowAmount(address)` and selector `0xca7453d4`.
```solidity
function getAvailableBorrowAmount(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAvailableBorrowAmountCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAvailableBorrowAmount(address)`](getAvailableBorrowAmountCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getAvailableBorrowAmountReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableBorrowAmountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableBorrowAmountCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableBorrowAmountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableBorrowAmountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableBorrowAmountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableBorrowAmountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAvailableBorrowAmountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAvailableBorrowAmountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAvailableBorrowAmount(address)";
            const SELECTOR: [u8; 4] = [202u8, 116u8, 83u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBestFeeTier(address,address,address,uint256)` and selector `0xa210e433`.
```solidity
function getBestFeeTier(address factory, address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint24 bestFeeTier, uint256 amountOut);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getBestFeeTierCall {
        pub factory: alloy::sol_types::private::Address,
        pub tokenIn: alloy::sol_types::private::Address,
        pub tokenOut: alloy::sol_types::private::Address,
        pub amountIn: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getBestFeeTier(address,address,address,uint256)`](getBestFeeTierCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getBestFeeTierReturn {
        pub bestFeeTier: alloy::sol_types::private::primitives::aliases::U24,
        pub amountOut: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBestFeeTierCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBestFeeTierCall) -> Self {
                    (value.factory, value.tokenIn, value.tokenOut, value.amountIn)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBestFeeTierCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        factory: tuple.0,
                        tokenIn: tuple.1,
                        tokenOut: tuple.2,
                        amountIn: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U24,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBestFeeTierReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBestFeeTierReturn) -> Self {
                    (value.bestFeeTier, value.amountOut)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBestFeeTierReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bestFeeTier: tuple.0,
                        amountOut: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBestFeeTierCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBestFeeTierReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBestFeeTier(address,address,address,uint256)";
            const SELECTOR: [u8; 4] = [162u8, 16u8, 228u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.factory,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountIn),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBorrowBalance(address)` and selector `0x7d6af079`.
```solidity
function getBorrowBalance(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getBorrowBalanceCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBorrowBalance(address)`](getBorrowBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getBorrowBalanceReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBorrowBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBorrowBalanceCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBorrowBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBorrowBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBorrowBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBorrowBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBorrowBalanceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBorrowBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBorrowBalance(address)";
            const SELECTOR: [u8; 4] = [125u8, 106u8, 240u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getDerivedAssets(address)` and selector `0x69c812ba`.
```solidity
function getDerivedAssets(address asset) external view returns (address[] memory assets);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getDerivedAssetsCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getDerivedAssets(address)`](getDerivedAssetsCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getDerivedAssetsReturn {
        pub assets: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDerivedAssetsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDerivedAssetsCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDerivedAssetsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDerivedAssetsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDerivedAssetsReturn) -> Self {
                    (value.assets,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDerivedAssetsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { assets: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDerivedAssetsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDerivedAssetsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDerivedAssets(address)";
            const SELECTOR: [u8; 4] = [105u8, 200u8, 18u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLTV(address)` and selector `0xaca25f9a`.
```solidity
function getLTV(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLTVCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getLTV(address)`](getLTVCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLTVReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLTVCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLTVCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLTVCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLTVReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLTVReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLTVReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLTVCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLTVReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLTV(address)";
            const SELECTOR: [u8; 4] = [172u8, 162u8, 95u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLiquidity(address)` and selector `0xa747b93b`.
```solidity
function getLiquidity(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLiquidityCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getLiquidity(address)`](getLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLiquidityReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLiquidityCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLiquidityCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLiquidityReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLiquidityReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLiquidityCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLiquidityReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLiquidity(address)";
            const SELECTOR: [u8; 4] = [167u8, 71u8, 185u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPositionData()` and selector `0xe8f37963`.
```solidity
function getPositionData() external view returns (uint256 totalCollateral, uint256 totalDebt, uint256 availableBorrows, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getPositionDataCall {}
    ///Container type for the return parameters of the [`getPositionData()`](getPositionDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getPositionDataReturn {
        pub totalCollateral: alloy::sol_types::private::primitives::aliases::U256,
        pub totalDebt: alloy::sol_types::private::primitives::aliases::U256,
        pub availableBorrows: alloy::sol_types::private::primitives::aliases::U256,
        pub currentLiquidationThreshold: alloy::sol_types::private::primitives::aliases::U256,
        pub ltv: alloy::sol_types::private::primitives::aliases::U256,
        pub healthFactor: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPositionDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPositionDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPositionDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPositionDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPositionDataReturn) -> Self {
                    (
                        value.totalCollateral,
                        value.totalDebt,
                        value.availableBorrows,
                        value.currentLiquidationThreshold,
                        value.ltv,
                        value.healthFactor,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPositionDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        totalCollateral: tuple.0,
                        totalDebt: tuple.1,
                        availableBorrows: tuple.2,
                        currentLiquidationThreshold: tuple.3,
                        ltv: tuple.4,
                        healthFactor: tuple.5,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPositionDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPositionDataReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPositionData()";
            const SELECTOR: [u8; 4] = [232u8, 243u8, 121u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getSupplyBalance(address)` and selector `0xf38e266a`.
```solidity
function getSupplyBalance(address asset) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getSupplyBalanceCall {
        pub asset: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getSupplyBalance(address)`](getSupplyBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getSupplyBalanceReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupplyBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupplyBalanceCall) -> Self {
                    (value.asset,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupplyBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { asset: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSupplyBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSupplyBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSupplyBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSupplyBalanceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSupplyBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSupplyBalance(address)";
            const SELECTOR: [u8; 4] = [243u8, 142u8, 38u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `leverage(address,address,uint256,uint256,uint24)` and selector `0x329ef6df`.
```solidity
function leverage(address supplyAsset, address borrowAsset, uint256 principal, uint256 iterations, uint24 feeTier) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct leverageCall {
        pub supplyAsset: alloy::sol_types::private::Address,
        pub borrowAsset: alloy::sol_types::private::Address,
        pub principal: alloy::sol_types::private::primitives::aliases::U256,
        pub iterations: alloy::sol_types::private::primitives::aliases::U256,
        pub feeTier: alloy::sol_types::private::primitives::aliases::U24,
    }
    ///Container type for the return parameters of the [`leverage(address,address,uint256,uint256,uint24)`](leverageCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct leverageReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leverageCall> for UnderlyingRustTuple<'_> {
                fn from(value: leverageCall) -> Self {
                    (
                        value.supplyAsset,
                        value.borrowAsset,
                        value.principal,
                        value.iterations,
                        value.feeTier,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leverageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        supplyAsset: tuple.0,
                        borrowAsset: tuple.1,
                        principal: tuple.2,
                        iterations: tuple.3,
                        feeTier: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leverageReturn> for UnderlyingRustTuple<'_> {
                fn from(value: leverageReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leverageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leverageCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leverageReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leverage(address,address,uint256,uint256,uint24)";
            const SELECTOR: [u8; 4] = [50u8, 158u8, 246u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.supplyAsset,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.borrowAsset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.principal),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iterations),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeTier),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `leverageFully(address,address,uint256,uint24)` and selector `0xcce1cd6d`.
```solidity
function leverageFully(address supplyAsset, address borrowAsset, uint256 iterations, uint24 feeTier) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct leverageFullyCall {
        pub supplyAsset: alloy::sol_types::private::Address,
        pub borrowAsset: alloy::sol_types::private::Address,
        pub iterations: alloy::sol_types::private::primitives::aliases::U256,
        pub feeTier: alloy::sol_types::private::primitives::aliases::U24,
    }
    ///Container type for the return parameters of the [`leverageFully(address,address,uint256,uint24)`](leverageFullyCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct leverageFullyReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leverageFullyCall> for UnderlyingRustTuple<'_> {
                fn from(value: leverageFullyCall) -> Self {
                    (
                        value.supplyAsset,
                        value.borrowAsset,
                        value.iterations,
                        value.feeTier,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leverageFullyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        supplyAsset: tuple.0,
                        borrowAsset: tuple.1,
                        iterations: tuple.2,
                        feeTier: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leverageFullyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: leverageFullyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leverageFullyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leverageFullyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leverageFullyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leverageFully(address,address,uint256,uint24)";
            const SELECTOR: [u8; 4] = [204u8, 225u8, 205u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.supplyAsset,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.borrowAsset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iterations),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeTier),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `swapUniswapV3(address,address,uint256,uint24)` and selector `0x5f6a18db`.
```solidity
function swapUniswapV3(address tokenIn, address tokenOut, uint256 amountIn, uint24 feeTier) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapUniswapV3Call {
        pub tokenIn: alloy::sol_types::private::Address,
        pub tokenOut: alloy::sol_types::private::Address,
        pub amountIn: alloy::sol_types::private::primitives::aliases::U256,
        pub feeTier: alloy::sol_types::private::primitives::aliases::U24,
    }
    ///Container type for the return parameters of the [`swapUniswapV3(address,address,uint256,uint24)`](swapUniswapV3Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapUniswapV3Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U24,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapUniswapV3Call> for UnderlyingRustTuple<'_> {
                fn from(value: swapUniswapV3Call) -> Self {
                    (value.tokenIn, value.tokenOut, value.amountIn, value.feeTier)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapUniswapV3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        tokenIn: tuple.0,
                        tokenOut: tuple.1,
                        amountIn: tuple.2,
                        feeTier: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapUniswapV3Return> for UnderlyingRustTuple<'_> {
                fn from(value: swapUniswapV3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapUniswapV3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for swapUniswapV3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = swapUniswapV3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "swapUniswapV3(address,address,uint256,uint24)";
            const SELECTOR: [u8; 4] = [95u8, 106u8, 24u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountIn),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeTier),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`AaveLooper`](self) function calls.
    pub enum AaveLooperCalls {
        AGGREGATION_ROUTER_V5(AGGREGATION_ROUTER_V5Call),
        FEE_TIERS(FEE_TIERSCall),
        LENDING_POOL(LENDING_POOLCall),
        OWNER(OWNERCall),
        SAFE_BUFFER(SAFE_BUFFERCall),
        UNISWAP_V3_FACTORY(UNISWAP_V3_FACTORYCall),
        UNISWAP_V3_ROUTER(UNISWAP_V3_ROUTERCall),
        USE_VARIABLE_DEBT(USE_VARIABLE_DEBTCall),
        WETH_ADDRESS(WETH_ADDRESSCall),
        _borrow(_borrowCall),
        _redeemSupply(_redeemSupplyCall),
        _repayBorrow(_repayBorrowCall),
        _supply(_supplyCall),
        _withdrawToOwner(_withdrawToOwnerCall),
        emergencyFunctionCall(emergencyFunctionCallCall),
        emergencyFunctionDelegateCall(emergencyFunctionDelegateCallCall),
        executeOperation(executeOperationCall),
        exitPosition(exitPositionCall),
        exitPositionWithFlashLoan(exitPositionWithFlashLoanCall),
        getAssetBalance(getAssetBalanceCall),
        getAssetPrice(getAssetPriceCall),
        getAvailableBorrowAmount(getAvailableBorrowAmountCall),
        getBestFeeTier(getBestFeeTierCall),
        getBorrowBalance(getBorrowBalanceCall),
        getDerivedAssets(getDerivedAssetsCall),
        getLTV(getLTVCall),
        getLiquidity(getLiquidityCall),
        getPositionData(getPositionDataCall),
        getSupplyBalance(getSupplyBalanceCall),
        leverage(leverageCall),
        leverageFully(leverageFullyCall),
        swapUniswapV3(swapUniswapV3Call),
    }
    #[automatically_derived]
    impl AaveLooperCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 1u8, 65u8, 229u8],
            [13u8, 125u8, 227u8, 127u8],
            [17u8, 120u8, 3u8, 227u8],
            [27u8, 17u8, 208u8, 255u8],
            [42u8, 176u8, 170u8, 187u8],
            [50u8, 158u8, 246u8, 223u8],
            [65u8, 198u8, 74u8, 47u8],
            [83u8, 115u8, 67u8, 63u8],
            [88u8, 134u8, 231u8, 193u8],
            [93u8, 223u8, 188u8, 91u8],
            [95u8, 106u8, 24u8, 219u8],
            [105u8, 200u8, 18u8, 186u8],
            [107u8, 27u8, 155u8, 32u8],
            [117u8, 102u8, 149u8, 81u8],
            [125u8, 106u8, 240u8, 121u8],
            [138u8, 12u8, 207u8, 108u8],
            [162u8, 16u8, 228u8, 51u8],
            [167u8, 71u8, 185u8, 59u8],
            [172u8, 162u8, 95u8, 154u8],
            [177u8, 29u8, 231u8, 227u8],
            [179u8, 89u8, 111u8, 7u8],
            [180u8, 220u8, 252u8, 119u8],
            [180u8, 248u8, 176u8, 123u8],
            [188u8, 167u8, 164u8, 96u8],
            [199u8, 160u8, 182u8, 24u8],
            [202u8, 116u8, 83u8, 212u8],
            [204u8, 225u8, 205u8, 109u8],
            [227u8, 99u8, 56u8, 219u8],
            [231u8, 141u8, 115u8, 173u8],
            [232u8, 243u8, 121u8, 99u8],
            [243u8, 142u8, 38u8, 106u8],
            [247u8, 62u8, 90u8, 171u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for AaveLooperCalls {
        const NAME: &'static str = "AaveLooperCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 32usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AGGREGATION_ROUTER_V5(_) => {
                    <AGGREGATION_ROUTER_V5Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::FEE_TIERS(_) => {
                    <FEE_TIERSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LENDING_POOL(_) => {
                    <LENDING_POOLCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::OWNER(_) => <OWNERCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::SAFE_BUFFER(_) => {
                    <SAFE_BUFFERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UNISWAP_V3_FACTORY(_) => {
                    <UNISWAP_V3_FACTORYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UNISWAP_V3_ROUTER(_) => {
                    <UNISWAP_V3_ROUTERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::USE_VARIABLE_DEBT(_) => {
                    <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::WETH_ADDRESS(_) => {
                    <WETH_ADDRESSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_borrow(_) => <_borrowCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::_redeemSupply(_) => {
                    <_redeemSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_repayBorrow(_) => {
                    <_repayBorrowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::_supply(_) => <_supplyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::_withdrawToOwner(_) => {
                    <_withdrawToOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emergencyFunctionCall(_) => {
                    <emergencyFunctionCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emergencyFunctionDelegateCall(_) => {
                    <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeOperation(_) => {
                    <executeOperationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exitPosition(_) => {
                    <exitPositionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exitPositionWithFlashLoan(_) => {
                    <exitPositionWithFlashLoanCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAssetBalance(_) => {
                    <getAssetBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAssetPrice(_) => {
                    <getAssetPriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAvailableBorrowAmount(_) => {
                    <getAvailableBorrowAmountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBestFeeTier(_) => {
                    <getBestFeeTierCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBorrowBalance(_) => {
                    <getBorrowBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDerivedAssets(_) => {
                    <getDerivedAssetsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLTV(_) => <getLTVCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLiquidity(_) => {
                    <getLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPositionData(_) => {
                    <getPositionDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSupplyBalance(_) => {
                    <getSupplyBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leverage(_) => <leverageCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::leverageFully(_) => {
                    <leverageFullyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::swapUniswapV3(_) => {
                    <swapUniswapV3Call as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<AaveLooperCalls>] = &[
                {
                    fn WETH_ADDRESS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <WETH_ADDRESSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::WETH_ADDRESS)
                    }
                    WETH_ADDRESS
                },
                {
                    fn exitPositionWithFlashLoan(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <exitPositionWithFlashLoanCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::exitPositionWithFlashLoan)
                    }
                    exitPositionWithFlashLoan
                },
                {
                    fn OWNER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <OWNERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::OWNER)
                    }
                    OWNER
                },
                {
                    fn executeOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <executeOperationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::executeOperation)
                    }
                    executeOperation
                },
                {
                    fn emergencyFunctionDelegateCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::emergencyFunctionDelegateCall)
                    }
                    emergencyFunctionDelegateCall
                },
                {
                    fn leverage(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <leverageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::leverage)
                    }
                    leverage
                },
                {
                    fn UNISWAP_V3_ROUTER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <UNISWAP_V3_ROUTERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::UNISWAP_V3_ROUTER)
                    }
                    UNISWAP_V3_ROUTER
                },
                {
                    fn getAssetBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getAssetBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getAssetBalance)
                    }
                    getAssetBalance
                },
                {
                    fn _withdrawToOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_withdrawToOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_withdrawToOwner)
                    }
                    _withdrawToOwner
                },
                {
                    fn USE_VARIABLE_DEBT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::USE_VARIABLE_DEBT)
                    }
                    USE_VARIABLE_DEBT
                },
                {
                    fn swapUniswapV3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <swapUniswapV3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::swapUniswapV3)
                    }
                    swapUniswapV3
                },
                {
                    fn getDerivedAssets(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getDerivedAssetsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getDerivedAssets)
                    }
                    getDerivedAssets
                },
                {
                    fn FEE_TIERS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <FEE_TIERSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::FEE_TIERS)
                    }
                    FEE_TIERS
                },
                {
                    fn exitPosition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <exitPositionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::exitPosition)
                    }
                    exitPosition
                },
                {
                    fn getBorrowBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getBorrowBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getBorrowBalance)
                    }
                    getBorrowBalance
                },
                {
                    fn SAFE_BUFFER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <SAFE_BUFFERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::SAFE_BUFFER)
                    }
                    SAFE_BUFFER
                },
                {
                    fn getBestFeeTier(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getBestFeeTierCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getBestFeeTier)
                    }
                    getBestFeeTier
                },
                {
                    fn getLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getLiquidity)
                    }
                    getLiquidity
                },
                {
                    fn getLTV(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getLTVCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getLTV)
                    }
                    getLTV
                },
                {
                    fn AGGREGATION_ROUTER_V5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <AGGREGATION_ROUTER_V5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::AGGREGATION_ROUTER_V5)
                    }
                    AGGREGATION_ROUTER_V5
                },
                {
                    fn getAssetPrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getAssetPriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getAssetPrice)
                    }
                    getAssetPrice
                },
                {
                    fn LENDING_POOL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <LENDING_POOLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::LENDING_POOL)
                    }
                    LENDING_POOL
                },
                {
                    fn _repayBorrow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_repayBorrowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_repayBorrow)
                    }
                    _repayBorrow
                },
                {
                    fn _redeemSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_redeemSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_redeemSupply)
                    }
                    _redeemSupply
                },
                {
                    fn _borrow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_borrowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_borrow)
                    }
                    _borrow
                },
                {
                    fn getAvailableBorrowAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getAvailableBorrowAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getAvailableBorrowAmount)
                    }
                    getAvailableBorrowAmount
                },
                {
                    fn leverageFully(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <leverageFullyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::leverageFully)
                    }
                    leverageFully
                },
                {
                    fn _supply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <_supplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::_supply)
                    }
                    _supply
                },
                {
                    fn emergencyFunctionCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <emergencyFunctionCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::emergencyFunctionCall)
                    }
                    emergencyFunctionCall
                },
                {
                    fn getPositionData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getPositionDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getPositionData)
                    }
                    getPositionData
                },
                {
                    fn getSupplyBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <getSupplyBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::getSupplyBalance)
                    }
                    getSupplyBalance
                },
                {
                    fn UNISWAP_V3_FACTORY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperCalls> {
                        <UNISWAP_V3_FACTORYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperCalls::UNISWAP_V3_FACTORY)
                    }
                    UNISWAP_V3_FACTORY
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AGGREGATION_ROUTER_V5(inner) => {
                    <AGGREGATION_ROUTER_V5Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FEE_TIERS(inner) => {
                    <FEE_TIERSCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::LENDING_POOL(inner) => {
                    <LENDING_POOLCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OWNER(inner) => {
                    <OWNERCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SAFE_BUFFER(inner) => {
                    <SAFE_BUFFERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UNISWAP_V3_FACTORY(inner) => {
                    <UNISWAP_V3_FACTORYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UNISWAP_V3_ROUTER(inner) => {
                    <UNISWAP_V3_ROUTERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::USE_VARIABLE_DEBT(inner) => {
                    <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WETH_ADDRESS(inner) => {
                    <WETH_ADDRESSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_borrow(inner) => {
                    <_borrowCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::_redeemSupply(inner) => {
                    <_redeemSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_repayBorrow(inner) => {
                    <_repayBorrowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::_supply(inner) => {
                    <_supplyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::_withdrawToOwner(inner) => {
                    <_withdrawToOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emergencyFunctionCall(inner) => {
                    <emergencyFunctionCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emergencyFunctionDelegateCall(inner) => {
                    <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeOperation(inner) => {
                    <executeOperationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::exitPosition(inner) => {
                    <exitPositionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::exitPositionWithFlashLoan(inner) => {
                    <exitPositionWithFlashLoanCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAssetBalance(inner) => {
                    <getAssetBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAssetPrice(inner) => {
                    <getAssetPriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAvailableBorrowAmount(inner) => {
                    <getAvailableBorrowAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBestFeeTier(inner) => {
                    <getBestFeeTierCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBorrowBalance(inner) => {
                    <getBorrowBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDerivedAssets(inner) => {
                    <getDerivedAssetsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLTV(inner) => {
                    <getLTVCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getLiquidity(inner) => {
                    <getLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPositionData(inner) => {
                    <getPositionDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSupplyBalance(inner) => {
                    <getSupplyBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leverage(inner) => {
                    <leverageCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::leverageFully(inner) => {
                    <leverageFullyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::swapUniswapV3(inner) => {
                    <swapUniswapV3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AGGREGATION_ROUTER_V5(inner) => {
                    <AGGREGATION_ROUTER_V5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FEE_TIERS(inner) => {
                    <FEE_TIERSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LENDING_POOL(inner) => {
                    <LENDING_POOLCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OWNER(inner) => {
                    <OWNERCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::SAFE_BUFFER(inner) => {
                    <SAFE_BUFFERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UNISWAP_V3_FACTORY(inner) => {
                    <UNISWAP_V3_FACTORYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UNISWAP_V3_ROUTER(inner) => {
                    <UNISWAP_V3_ROUTERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::USE_VARIABLE_DEBT(inner) => {
                    <USE_VARIABLE_DEBTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WETH_ADDRESS(inner) => {
                    <WETH_ADDRESSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_borrow(inner) => {
                    <_borrowCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::_redeemSupply(inner) => {
                    <_redeemSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_repayBorrow(inner) => {
                    <_repayBorrowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::_supply(inner) => {
                    <_supplyCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::_withdrawToOwner(inner) => {
                    <_withdrawToOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emergencyFunctionCall(inner) => {
                    <emergencyFunctionCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emergencyFunctionDelegateCall(inner) => {
                    <emergencyFunctionDelegateCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeOperation(inner) => {
                    <executeOperationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exitPosition(inner) => {
                    <exitPositionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exitPositionWithFlashLoan(inner) => {
                    <exitPositionWithFlashLoanCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAssetBalance(inner) => {
                    <getAssetBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAssetPrice(inner) => {
                    <getAssetPriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAvailableBorrowAmount(inner) => {
                    <getAvailableBorrowAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBestFeeTier(inner) => {
                    <getBestFeeTierCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBorrowBalance(inner) => {
                    <getBorrowBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDerivedAssets(inner) => {
                    <getDerivedAssetsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLTV(inner) => {
                    <getLTVCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getLiquidity(inner) => {
                    <getLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPositionData(inner) => {
                    <getPositionDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSupplyBalance(inner) => {
                    <getSupplyBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leverage(inner) => {
                    <leverageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leverageFully(inner) => {
                    <leverageFullyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::swapUniswapV3(inner) => {
                    <swapUniswapV3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`AaveLooper`](self) custom errors.
    pub enum AaveLooperErrors {
        AddressEmptyCode(AddressEmptyCode),
        AddressInsufficientBalance(AddressInsufficientBalance),
        FailedInnerCall(FailedInnerCall),
        SafeERC20FailedOperation(SafeERC20FailedOperation),
    }
    #[automatically_derived]
    impl AaveLooperErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [20u8, 37u8, 234u8, 66u8],
            [82u8, 116u8, 175u8, 231u8],
            [153u8, 150u8, 179u8, 21u8],
            [205u8, 120u8, 96u8, 89u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for AaveLooperErrors {
        const NAME: &'static str = "AaveLooperErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressInsufficientBalance(_) => {
                    <AddressInsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedInnerCall(_) => {
                    <FailedInnerCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<AaveLooperErrors>] = &[
                {
                    fn FailedInnerCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <FailedInnerCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::FailedInnerCall)
                    }
                    FailedInnerCall
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::SafeERC20FailedOperation)
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn AddressInsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<AaveLooperErrors> {
                        <AddressInsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(AaveLooperErrors::AddressInsufficientBalance)
                    }
                    AddressInsufficientBalance
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AddressInsufficientBalance(inner) => {
                    <AddressInsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedInnerCall(inner) => {
                    <FailedInnerCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressInsufficientBalance(inner) => {
                    <AddressInsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedInnerCall(inner) => {
                    <FailedInnerCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`AaveLooper`](self) contract instance.

See the [wrapper's documentation](`AaveLooperInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> AaveLooperInstance<T, P, N> {
        AaveLooperInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        owner: alloy::sol_types::private::Address,
        lendingPool: alloy::sol_types::private::Address,
        wethAddress: alloy::sol_types::private::Address,
        uniswapV3Router: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<AaveLooperInstance<T, P, N>>,
    > {
        AaveLooperInstance::<
            T,
            P,
            N,
        >::deploy(provider, owner, lendingPool, wethAddress, uniswapV3Router)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        owner: alloy::sol_types::private::Address,
        lendingPool: alloy::sol_types::private::Address,
        wethAddress: alloy::sol_types::private::Address,
        uniswapV3Router: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        AaveLooperInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, owner, lendingPool, wethAddress, uniswapV3Router)
    }
    /**A [`AaveLooper`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`AaveLooper`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct AaveLooperInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for AaveLooperInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("AaveLooperInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AaveLooperInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`AaveLooper`](self) contract instance.

See the [wrapper's documentation](`AaveLooperInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            owner: alloy::sol_types::private::Address,
            lendingPool: alloy::sol_types::private::Address,
            wethAddress: alloy::sol_types::private::Address,
            uniswapV3Router: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<AaveLooperInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                owner,
                lendingPool,
                wethAddress,
                uniswapV3Router,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            owner: alloy::sol_types::private::Address,
            lendingPool: alloy::sol_types::private::Address,
            wethAddress: alloy::sol_types::private::Address,
            uniswapV3Router: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            owner,
                            lendingPool,
                            wethAddress,
                            uniswapV3Router,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> AaveLooperInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> AaveLooperInstance<T, P, N> {
            AaveLooperInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AaveLooperInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`AGGREGATION_ROUTER_V5`] function.
        pub fn AGGREGATION_ROUTER_V5(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, AGGREGATION_ROUTER_V5Call, N> {
            self.call_builder(&AGGREGATION_ROUTER_V5Call {})
        }
        ///Creates a new call builder for the [`FEE_TIERS`] function.
        pub fn FEE_TIERS(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, FEE_TIERSCall, N> {
            self.call_builder(&FEE_TIERSCall { _0 })
        }
        ///Creates a new call builder for the [`LENDING_POOL`] function.
        pub fn LENDING_POOL(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LENDING_POOLCall, N> {
            self.call_builder(&LENDING_POOLCall {})
        }
        ///Creates a new call builder for the [`OWNER`] function.
        pub fn OWNER(&self) -> alloy_contract::SolCallBuilder<T, &P, OWNERCall, N> {
            self.call_builder(&OWNERCall {})
        }
        ///Creates a new call builder for the [`SAFE_BUFFER`] function.
        pub fn SAFE_BUFFER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SAFE_BUFFERCall, N> {
            self.call_builder(&SAFE_BUFFERCall {})
        }
        ///Creates a new call builder for the [`UNISWAP_V3_FACTORY`] function.
        pub fn UNISWAP_V3_FACTORY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UNISWAP_V3_FACTORYCall, N> {
            self.call_builder(&UNISWAP_V3_FACTORYCall {})
        }
        ///Creates a new call builder for the [`UNISWAP_V3_ROUTER`] function.
        pub fn UNISWAP_V3_ROUTER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UNISWAP_V3_ROUTERCall, N> {
            self.call_builder(&UNISWAP_V3_ROUTERCall {})
        }
        ///Creates a new call builder for the [`USE_VARIABLE_DEBT`] function.
        pub fn USE_VARIABLE_DEBT(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, USE_VARIABLE_DEBTCall, N> {
            self.call_builder(&USE_VARIABLE_DEBTCall {})
        }
        ///Creates a new call builder for the [`WETH_ADDRESS`] function.
        pub fn WETH_ADDRESS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, WETH_ADDRESSCall, N> {
            self.call_builder(&WETH_ADDRESSCall {})
        }
        ///Creates a new call builder for the [`_borrow`] function.
        pub fn _borrow(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _borrowCall, N> {
            self.call_builder(&_borrowCall { asset, amount })
        }
        ///Creates a new call builder for the [`_redeemSupply`] function.
        pub fn _redeemSupply(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _redeemSupplyCall, N> {
            self.call_builder(&_redeemSupplyCall { asset, amount })
        }
        ///Creates a new call builder for the [`_repayBorrow`] function.
        pub fn _repayBorrow(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _repayBorrowCall, N> {
            self.call_builder(&_repayBorrowCall { asset, amount })
        }
        ///Creates a new call builder for the [`_supply`] function.
        pub fn _supply(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, _supplyCall, N> {
            self.call_builder(&_supplyCall { asset, amount })
        }
        ///Creates a new call builder for the [`_withdrawToOwner`] function.
        pub fn _withdrawToOwner(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, _withdrawToOwnerCall, N> {
            self.call_builder(&_withdrawToOwnerCall { asset })
        }
        ///Creates a new call builder for the [`emergencyFunctionCall`] function.
        pub fn emergencyFunctionCall(
            &self,
            target: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, emergencyFunctionCallCall, N> {
            self.call_builder(
                &emergencyFunctionCallCall {
                    target,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`emergencyFunctionDelegateCall`] function.
        pub fn emergencyFunctionDelegateCall(
            &self,
            target: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            emergencyFunctionDelegateCallCall,
            N,
        > {
            self.call_builder(
                &emergencyFunctionDelegateCallCall {
                    target,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`executeOperation`] function.
        pub fn executeOperation(
            &self,
            asset: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            premium: alloy::sol_types::private::primitives::aliases::U256,
            initiator: alloy::sol_types::private::Address,
            params: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, executeOperationCall, N> {
            self.call_builder(
                &executeOperationCall {
                    asset,
                    amount,
                    premium,
                    initiator,
                    params,
                },
            )
        }
        ///Creates a new call builder for the [`exitPosition`] function.
        pub fn exitPosition(
            &self,
            supplyAsset: alloy::sol_types::private::Address,
            borrowAsset: alloy::sol_types::private::Address,
            maxIterations: alloy::sol_types::private::primitives::aliases::U256,
            feeTier: alloy::sol_types::private::primitives::aliases::U24,
        ) -> alloy_contract::SolCallBuilder<T, &P, exitPositionCall, N> {
            self.call_builder(
                &exitPositionCall {
                    supplyAsset,
                    borrowAsset,
                    maxIterations,
                    feeTier,
                },
            )
        }
        ///Creates a new call builder for the [`exitPositionWithFlashLoan`] function.
        pub fn exitPositionWithFlashLoan(
            &self,
            supplyAsset: alloy::sol_types::private::Address,
            borrowAsset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, exitPositionWithFlashLoanCall, N> {
            self.call_builder(
                &exitPositionWithFlashLoanCall {
                    supplyAsset,
                    borrowAsset,
                },
            )
        }
        ///Creates a new call builder for the [`getAssetBalance`] function.
        pub fn getAssetBalance(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAssetBalanceCall, N> {
            self.call_builder(&getAssetBalanceCall { asset })
        }
        ///Creates a new call builder for the [`getAssetPrice`] function.
        pub fn getAssetPrice(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAssetPriceCall, N> {
            self.call_builder(&getAssetPriceCall { asset })
        }
        ///Creates a new call builder for the [`getAvailableBorrowAmount`] function.
        pub fn getAvailableBorrowAmount(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAvailableBorrowAmountCall, N> {
            self.call_builder(
                &getAvailableBorrowAmountCall {
                    asset,
                },
            )
        }
        ///Creates a new call builder for the [`getBestFeeTier`] function.
        pub fn getBestFeeTier(
            &self,
            factory: alloy::sol_types::private::Address,
            tokenIn: alloy::sol_types::private::Address,
            tokenOut: alloy::sol_types::private::Address,
            amountIn: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBestFeeTierCall, N> {
            self.call_builder(
                &getBestFeeTierCall {
                    factory,
                    tokenIn,
                    tokenOut,
                    amountIn,
                },
            )
        }
        ///Creates a new call builder for the [`getBorrowBalance`] function.
        pub fn getBorrowBalance(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBorrowBalanceCall, N> {
            self.call_builder(&getBorrowBalanceCall { asset })
        }
        ///Creates a new call builder for the [`getDerivedAssets`] function.
        pub fn getDerivedAssets(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDerivedAssetsCall, N> {
            self.call_builder(&getDerivedAssetsCall { asset })
        }
        ///Creates a new call builder for the [`getLTV`] function.
        pub fn getLTV(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLTVCall, N> {
            self.call_builder(&getLTVCall { asset })
        }
        ///Creates a new call builder for the [`getLiquidity`] function.
        pub fn getLiquidity(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLiquidityCall, N> {
            self.call_builder(&getLiquidityCall { asset })
        }
        ///Creates a new call builder for the [`getPositionData`] function.
        pub fn getPositionData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPositionDataCall, N> {
            self.call_builder(&getPositionDataCall {})
        }
        ///Creates a new call builder for the [`getSupplyBalance`] function.
        pub fn getSupplyBalance(
            &self,
            asset: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSupplyBalanceCall, N> {
            self.call_builder(&getSupplyBalanceCall { asset })
        }
        ///Creates a new call builder for the [`leverage`] function.
        pub fn leverage(
            &self,
            supplyAsset: alloy::sol_types::private::Address,
            borrowAsset: alloy::sol_types::private::Address,
            principal: alloy::sol_types::private::primitives::aliases::U256,
            iterations: alloy::sol_types::private::primitives::aliases::U256,
            feeTier: alloy::sol_types::private::primitives::aliases::U24,
        ) -> alloy_contract::SolCallBuilder<T, &P, leverageCall, N> {
            self.call_builder(
                &leverageCall {
                    supplyAsset,
                    borrowAsset,
                    principal,
                    iterations,
                    feeTier,
                },
            )
        }
        ///Creates a new call builder for the [`leverageFully`] function.
        pub fn leverageFully(
            &self,
            supplyAsset: alloy::sol_types::private::Address,
            borrowAsset: alloy::sol_types::private::Address,
            iterations: alloy::sol_types::private::primitives::aliases::U256,
            feeTier: alloy::sol_types::private::primitives::aliases::U24,
        ) -> alloy_contract::SolCallBuilder<T, &P, leverageFullyCall, N> {
            self.call_builder(
                &leverageFullyCall {
                    supplyAsset,
                    borrowAsset,
                    iterations,
                    feeTier,
                },
            )
        }
        ///Creates a new call builder for the [`swapUniswapV3`] function.
        pub fn swapUniswapV3(
            &self,
            tokenIn: alloy::sol_types::private::Address,
            tokenOut: alloy::sol_types::private::Address,
            amountIn: alloy::sol_types::private::primitives::aliases::U256,
            feeTier: alloy::sol_types::private::primitives::aliases::U24,
        ) -> alloy_contract::SolCallBuilder<T, &P, swapUniswapV3Call, N> {
            self.call_builder(
                &swapUniswapV3Call {
                    tokenIn,
                    tokenOut,
                    amountIn,
                    feeTier,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > AaveLooperInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
